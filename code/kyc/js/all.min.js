"use strict";

angular.module("features", []);

angular.module("kyc.controllers", []);

angular.module("kyc.resources", []);

angular.module("kyc.charts", []);

angular.module("kyc.services", []);

angular.module("kyc.directives", []);

angular.module("kyc.reports", []);

angular.module("kyc", [ "ngRoute", "ngResource", "ngSanitize", "kyc.directives", "kyc.resources", "kyc.services", "kyc.charts", "kyc.controllers", "kyc.resources", "kyc.filters", "kyc.reports", "loaders", "notification", "mm.foundation" ]).run([ "$rootScope", "ACCOUNT_ID", "$http", function($rootScope, ACCOUNT_ID, $http) {
    $rootScope.requests = 0;
    $http.get("/api/accounts/" + ACCOUNT_ID + "/features").then(function(result) {
        var found = false;
        if (result && result.data) {
            angular.forEach(result.data, function(accountFeature) {
                if (accountFeature.featureId === 4 && (accountFeature.status === "INSTALLED" || accountFeature.status === "TRIAL")) found = true;
            });
        }
        if (!found) window.location.replace("/shop#/feature/4");
    });
} ]).config([ "$routeProvider", function($routeProvider) {
    $routeProvider.when("/dashboard", {
        templateUrl: "/code/kyc/partials/dashboard.php",
        controller: "DashboardCtrl",
        resolve: {
            load: function($route, AllCharts, $AjaxInterceptor) {
                $AjaxInterceptor.start();
                return AllCharts.promise;
            }
        }
    });
    $routeProvider.when("/stock", {
        templateUrl: "/code/kyc/partials/stock.php",
        controller: "StockCtrl",
        resolve: {
            load: function($route, OrderService, $AjaxInterceptor) {
                $AjaxInterceptor.start();
                return OrderService.load();
            }
        }
    });
    $routeProvider.when("/customers", {
        templateUrl: "/code/kyc/partials/customers.php",
        controller: "CustomersCtrl",
        resolve: {
            load: function($route, OrderService, $AjaxInterceptor) {
                $AjaxInterceptor.start();
                return OrderService.load();
            }
        }
    });
    $routeProvider.when("/reports", {
        templateUrl: "/code/kyc/partials/reports.php",
        controller: "ReportsCtrl",
        resolve: {
            load: function($route, AllReports, $AjaxInterceptor) {
                $AjaxInterceptor.start();
                return AllReports.init();
            }
        }
    });
    $routeProvider.when("/stream", {
        templateUrl: "/code/kyc/partials/stream.php",
        controller: "StreamCtrl",
        resolve: {
            load: function($route, OrderService, $AjaxInterceptor) {
                $AjaxInterceptor.start();
                return OrderService.load();
            }
        }
    });
    $routeProvider.otherwise({
        redirectTo: "/dashboard"
    });
} ]);

angular.module("notification", [ "ngSanitize" ]).controller("confirmModalController", [ "$scope", "$modalInstance", "data", "deffered", "$http", "$templateCache", "$compile", "$sce", function($scope, $modalInstance, data, deffered, $http, $templateCache, $compile, $sce) {
    $scope.title = data.title || "";
    if (data.hasOwnProperty("templateFullUrl") && data.templateFullUrl) {
        angular.extend($scope, data.scope);
    } else if (data.hasOwnProperty("templateUrl") && data.templateUrl) {
        $scope.templateUrl = data.templateUrl;
        $http.get(templatePath + data.templateUrl).then(function(response) {
            var scopeChild = $scope.$new();
            angular.extend(scopeChild, data.scope);
            angular.element("#contentPartial").html($compile(response.data)(scopeChild));
        });
    } else {
        $scope.content = data.content || "";
    }
    if (data.hasOwnProperty("scope") && data.scope) {
        $scope = angular.extend($scope, data.scope);
    }
    $scope.toTrusted = function(html) {
        return $sce.trustAsHtml(html || "");
    };
    $scope.showTerm = data.showTerm || false;
    $scope.acceptTerm = false;
    if (data.btnOk === false) {
        $scope.btnOk = false;
    } else {
        $scope.btnOk = data.btnOk || _tr("OK");
    }
    if (data.btnCancel === false) {
        data.btnCancel = false;
    } else {
        $scope.btnCancel = data.btnCancel || _tr("CANCEL");
    }
    $scope.changeTerm = function(newTerm) {
        $scope.acceptTerm = newTerm;
    };
    $scope.send = function() {
        $modalInstance.close();
        deffered.resolve({
            acceptTerm: $scope.acceptTerm
        });
    };
    $scope.cancel = function() {
        $modalInstance.close();
        deffered.reject({
            acceptTerm: $scope.acceptTerm
        });
    };
} ]).service("$notification", [ "$modal", "$q", "$sce", function($modal, $q, $sce) {
    var templatePath = "/code/notification/templates/";
    var confirm = function(data) {
        var deffered = $q.defer();
        data = data || {};
        if (data.hasOwnProperty("templateFullUrl") && data.templateFullUrl) {
            data.templateFullUrl = templatePath + data.templateFullUrl;
        }
        var modalCofirm = $modal.open({
            templateUrl: data.templateFullUrl || "/code/notification/notification.htm",
            windowClass: "modal-preoday " + (data.windowClass || ""),
            controller: "confirmModalController",
            resolve: {
                data: function() {
                    return data;
                },
                deffered: function() {
                    return deffered;
                }
            }
        });
        modalCofirm.opened.then(function() {
            setTimeout(function() {
                var maxWidth = 0;
                $(".notificationButtons button").each(function() {
                    maxWidth = maxWidth > $(this).width() ? maxWidth : $(this).width();
                }).width(maxWidth);
                $(".modal-preoday").addClass("active");
            }, 400);
        });
        return deffered.promise;
    };
    return {
        confirm: confirm
    };
} ]);

"use strict";

angular.module("kyc.services", []).service("$chartService", [ "ChartType", "$filter", "TickInterval", function(ChartType, $filter, TickInterval) {
    var area = function(value) {
        return {
            options: {
                chart: {
                    type: "areaspline",
                    height: "250"
                },
                exporting: {
                    enabled: false
                },
                plotOptions: {
                    line: {
                        marker: {
                            enabled: false
                        }
                    },
                    areaspline: {
                        lineWidth: 0,
                        fillColor: {
                            linearGradient: {
                                x1: 0,
                                y1: 0,
                                x2: 0,
                                y2: 1
                            },
                            stops: [ [ 0, "#523E8A" ], [ 1, "#1AA1DB" ] ]
                        },
                        marker: {
                            enabled: false
                        }
                    }
                }
            },
            credits: {
                enabled: false
            },
            title: {
                text: ""
            },
            xAxis: {
                type: "datetime",
                minTickInterval: 24 * 3600 * 1e3,
                labels: {
                    enabled: false
                }
            },
            yAxis: {
                gridLineWidth: 0,
                minorGridLineWidth: 0,
                title: {
                    text: ""
                },
                labels: {
                    enabled: false
                }
            },
            series: [ {
                showInLegend: false,
                enableMouseTracking: false,
                name: "",
                data: value.data
            } ]
        };
    };
    var areaModal = function(value) {
        return {
            options: {
                chart: {
                    type: "areaspline",
                    height: "250"
                },
                exporting: {
                    enabled: false
                },
                plotOptions: {
                    line: {
                        marker: {
                            enabled: false
                        }
                    },
                    series: {
                        marker: {
                            fillColor: "#126FB2",
                            lineColor: "#126FB2",
                            lineWidth: 2
                        }
                    },
                    areaspline: {
                        color: "#E7F1F7",
                        lineColor: "#126FB2",
                        lineWidth: 3,
                        marker: {
                            fillColor: "#126FB2",
                            enabled: false
                        }
                    }
                },
                tooltip: {
                    borderWidth: 0,
                    backgroundColor: "transparent",
                    shadow: false,
                    useHTML: true,
                    positioner: function(boxWidth, boxHeight, point) {
                        var substract = 20;
                        if (value.currency) {
                            substract = 0;
                        }
                        return {
                            x: point.plotX - substract,
                            y: point.plotY - boxHeight
                        };
                    },
                    formatter: function() {
                        var date;
                        if (this.series.xAxis.tickInterval === TickInterval.MONTH) {
                            date = $filter("date")(new Date(this.x), "MMM yyyy");
                        } else if (this.series.xAxis.tickInterval === TickInterval.WEEK) {
                            date = moment(this.x).startOf("week").format("DD MMM YYYY") + " <br /> - <br />" + moment(this.x).endOf("week").format("DD MMM YYYY");
                        } else {
                            date = $filter("date")(new Date(this.x), "dd MMM yyyy");
                        }
                        var ui_str = '<div style="position:relative;"><div style="background-color: #1576B7; border-radius: 5px; color:#fff;font-family:\'Co Text W01 Light\'; text-align:center; padding:18px 8px;">' + date;
                        var tooltipText = this.y == 1 && value.tooltipText[value.tooltipText.length - 1].toLowerCase() === "s" ? value.tooltipText.slice(0, -1) : value.tooltipText;
                        ui_str += "<b style=\"color:#fff;font-size:160%;font-weight:bold;font-family:'Co Text W01 Bold';text-align:center;display:block;margin-top:8px;\">";
                        if (value.currency) ui_str += tooltipText + "" + this.y.toFixed(2) + "</b></div>"; else ui_str += this.y + "" + tooltipText + "</b></div>";
                        ui_str += '<span style="position: absolute; left: 42%; bottom: -8px; background:url(/img/arrowBlue.png) left top no-repeat; width: 15px; height: 8px; display: block;" "></span></div>';
                        return ui_str;
                    }
                }
            },
            credits: {
                enabled: false
            },
            title: {
                text: ""
            },
            xAxis: {
                type: "datetime",
                tickInterval: value.tickInterval,
                min: value.minTimestamp,
                max: value.maxTimestamp,
                labels: {
                    style: {
                        color: "#b3b6b8",
                        fontSize: "15px"
                    },
                    formatter: function() {
                        var date;
                        if (this.axis.tickInterval === TickInterval.MONTH) {
                            date = $filter("date")(new Date(this.value), "MMM");
                        } else if (this.axis.tickInterval === TickInterval.WEEK || this.axis.tickInterval === TickInterval.WEEK_THREE) {
                            date = $filter("date")(new Date(moment(this.value).startOf("day")), "dd.MMM");
                        } else {
                            date = $filter("date")(new Date(this.value), "dd.MMM");
                        }
                        return date;
                    }
                }
            },
            yAxis: {
                gridLineWidth: 0,
                minorGridLineWidth: 0,
                title: {
                    text: ""
                },
                labels: {
                    style: {
                        color: "#b3b6b8",
                        fontSize: "15px"
                    }
                }
            },
            series: [ {
                showInLegend: false,
                name: "",
                data: value.data,
                marker: {
                    symbol: "url(/img/marker.png)"
                }
            } ]
        };
    };
    var pie = function(value) {
        return {
            options: {
                chart: {
                    type: "pie",
                    height: "250",
                    events: {
                        load: function(event) {
                            setTimeout(function() {
                                $(".highcharts-legend-item rect").attr("rx", "20").attr("ry", "20").attr("width", "16").attr("height", "16").css({
                                    cursor: "pointer"
                                });
                            }, 100);
                        }
                    }
                },
                tooltip: {
                    hideDelay: 0,
                    borderWidth: 0,
                    backgroundColor: "#DBDBD9",
                    shadow: false,
                    useHTML: true,
                    positioner: function(boxWidth, boxHeight, point) {
                        return {
                            x: point.plotX - boxWidth / 2 + 10,
                            y: point.plotY - boxHeight - 5
                        };
                    },
                    formatter: function() {
                        return '<div style="position:relative;"><div class="tooltipPie" style="font-size: 14px; font-weight: 600; padding: 5px 7px">' + Highcharts.numberFormat(this.y, 1) + '</div> <span style="position: absolute; left: 42%; bottom: -15px; background:url(/img/arrowPie.png) left top no-repeat; width: 15px; height: 9px; display: block;" "></span> </div>';
                    }
                },
                exporting: {
                    enabled: false
                },
                plotOptions: {
                    pie: {
                        center: [ "20%", "55%" ],
                        borderWidth: 0
                    }
                },
                legend: {
                    width: 50,
                    enabled: true,
                    layout: "vertical",
                    verticalAlign: "middle",
                    align: "center",
                    borderWidth: 0,
                    itemMarginTop: 5,
                    itemMarginBottom: 5,
                    itemStyle: {
                        width: 210,
                        lineHeight: 20,
                        fontSize: 13
                    },
                    useHTML: false,
                    labelFormatter: function() {
                        var style = "font-family:Co Text W01 Light;";
                        style += "color:#46545d;";
                        return '<div style="' + style + '">' + this.name + "</div>";
                    }
                }
            },
            title: {
                text: ""
            },
            yAxis: {
                title: {
                    text: ""
                }
            },
            series: [ {
                data: value.data,
                size: "80%",
                innerSize: "65%",
                showInLegend: true,
                dataLabels: {
                    enabled: false
                }
            } ]
        };
    };
    var column = function(value) {
        return {
            options: {
                chart: {
                    height: "250",
                    type: "column"
                },
                exporting: {
                    enabled: false
                },
                plotOptions: {
                    column: {
                        borderRadius: 5
                    },
                    series: {
                        borderWidth: 0,
                        dataLabels: {
                            enabled: false,
                            format: "{point.y:.1f}"
                        }
                    }
                },
                tooltip: {
                    hideDelay: .1,
                    crosshairs: false,
                    shared: true,
                    followPointer: true,
                    borderWidth: 0,
                    backgroundColor: "#DBDBD9",
                    shadow: false,
                    useHTML: true,
                    positioner: function(boxWidth, boxHeight, point) {
                        return {
                            x: point.plotX - boxWidth / 2 + 10,
                            y: point.plotY - boxHeight - 5
                        };
                    },
                    formatter: function() {
                        return '<div class="tooltipPie" style="font-size: 14px; font-weight: 600; padding: 5px 7px">' + Highcharts.numberFormat(this.y, 1) + "</div>";
                    }
                }
            },
            title: {
                text: ""
            },
            xAxis: {
                type: "category",
                lineWidth: 0,
                tickWidth: 0
            },
            yAxis: {
                gridLineWidth: 0,
                minorGridLineWidth: 0,
                title: {
                    text: ""
                },
                labels: {
                    enabled: false
                }
            },
            series: [ {
                pointWidth: 200,
                name: "Customers",
                showInLegend: false,
                colorByPoint: false,
                color: {
                    linearGradient: {
                        x1: 1,
                        y1: 1,
                        x2: 0,
                        y2: 1
                    },
                    stops: [ [ 0, "#523E8A" ], [ 1, "#1AA1DB" ] ]
                },
                data: value.data
            } ]
        };
    };
    var getChart = function(type, value) {
        switch (type) {
          case ChartType.AREA:
            return area(value);
            break;

          case ChartType.AREA_MODAL:
            return areaModal(value);
            break;

          case ChartType.PIE:
            return pie(value);
            break;

          case ChartType.COLUMN:
            return column(value);
            break;
        }
    };
    return {
        area: area,
        areaModal: areaModal,
        pie: pie,
        column: column,
        getChart: getChart
    };
} ]);

angular.module("kyc.services").service("$grid", [ "ChartType", function(ChartType) {
    var populateItems = function(charts) {
        var values = [];
        var i = 1;
        var grid = 8;
        var col = 1;
        var row = 1;
        var $widgets = window.sessionStorage.getItem("widgets");
        if ($widgets) {
            $widgets = angular.fromJson($widgets);
        }
        angular.forEach(charts, function(value, key) {
            var data = {};
            data.display = true;
            data.title = value.title;
            data.num = i;
            if (value.type === ChartType.NUMBER) {
                data.showChart = false;
                data.size_x = 2;
                data.size_y = 1;
                data.value = value.data;
                data.currency = value.currency;
            } else {
                data.showChart = true;
                data.size_x = 4;
                data.size_y = 2;
                data.value = value;
                data.currency = value.currency;
            }
            if ($widgets) {
                data.order = $widgets[i].order;
                data.display = $widgets[i].display;
            }
            data.row = row;
            data.col = col;
            if (col + data.size_x > grid) {
                col = 1;
                ++row;
            } else {
                col = col + data.size_x;
            }
            ++i;
            values.push(data);
        });
        if ($widgets) {
            values.sort(function compare(a, b) {
                if (a.order < b.order) return -1;
                if (a.order > b.order) return 1;
                return 0;
            });
        }
        return values;
    };
    return {
        populateItems: populateItems
    };
} ]);

angular.module("loaders", []).service("$AjaxInterceptor", [ "$rootScope", "$timeout", function($rootScope, $timeout) {
    function setSpinner() {
        var target = document.getElementsByClassName(".loading-content");
        if (target.length > 0) var spinner = new Spinner().spin(target[0]);
    }
    return {
        start: function() {
            ++$rootScope.requests;
            setSpinner();
        },
        complete: function() {
            $timeout(function() {
                if ($rootScope.requests > 0) {
                    --$rootScope.requests;
                }
            }, 100);
        },
        isRequesting: function() {
            return $rootScope.requests > 0;
        }
    };
} ]);

angular.module("kyc.services").service("OutletService", [ "ACCOUNT_ID", "Outlet", function(ACCOUNT_ID, Outlet) {
    var outlets = [];
    this.init = function(callback) {
        outlets = Outlet.query({
            accountId: ACCOUNT_ID
        }, function(res) {
            callback(res);
        });
    };
    this.getOutlets = function() {
        return outlets;
    };
    this.getOutletName = function(outletId) {
        var found = false;
        angular.forEach(outlets, function(outlet) {
            if (outlet.id == outletId) {
                found = outlet.name;
            }
        });
        return found;
    };
} ]);

angular.module("kyc.services").factory("pusher", [ "PUSHER_KEY", function(PUSHER_KEY) {
    Pusher.log = function(message) {
        if (window.console && window.console.log) window.console.log(message);
    };
    var pusher;
    var channel;
    return {
        bind: function(venueId, outletIds, callback) {
            if (outletIds.length > 0) {
                angular.forEach(outletIds, function(outletId) {
                    channel = pusher.subscribe("preoday.order.outlet." + outletId);
                    channel.bind("update", callback);
                });
            } else {
                channel = pusher.subscribe("preoday.order.venue." + venueId);
                channel.bind("update", callback);
            }
        },
        reset: function() {
            if (pusher) {
                var chans = pusher.allChannels();
                angular.forEach(chans, function(channel) {
                    channel.unbind();
                    pusher.unsubscribe(channel.name);
                });
            } else {
                pusher = new Pusher(PUSHER_KEY);
            }
        },
        bindConnection: function(event, callback) {
            pusher.connection.bind(event, callback);
        }
    };
} ]);

angular.module("kyc.services").service("OrderService", [ "ACCOUNT_ID", "Order", function(ACCOUNT_ID, Order) {
    var orders;
    function getOrders() {
        return orders;
    }
    function getMinData() {
        return minData;
    }
    function getMaxData() {
        return maxData;
    }
    function load(callback, minCreated, maxCreated) {
        return Order.query({
            accountId: ACCOUNT_ID,
            maxCreated: maxCreated,
            minCreated: minCreated
        }, function(res) {
            orders = res;
            if (callback) callback(res);
        }).$promise;
    }
    return {
        load: load,
        getOrders: getOrders
    };
} ]);

angular.module("kyc.services").service("VenueService", [ "ACCOUNT_ID", "Venue", "$q", function(ACCOUNT_ID, Venue, $q) {
    var venue;
    function init() {
        var defer = $q.defer();
        var v = new Venue.query({
            accountId: ACCOUNT_ID
        }, function(result) {
            if (result && result.length > 0) venue = result[0];
            defer.resolve(venue);
        });
        return defer.promise;
    }
    var currencyMap = {
        GBP: {
            symbol: "%C2%A3",
            name: "Pound Sterling",
            symbol_native: "£",
            decimal_digits: 2,
            rounding: 0,
            code: "GBP",
            name_plural: "British pounds sterling"
        },
        EUR: {
            symbol: "%E2%82%AC",
            name: "Euro",
            symbol_native: "€",
            decimal_digits: 2,
            rounding: 0,
            code: "EUR",
            name_plural: "euros"
        },
        USD: {
            symbol: "$",
            name: "US Dollar",
            symbol_native: "$",
            decimal_digits: 2,
            rounding: 0,
            code: "USD",
            name_plural: "US dollars"
        }
    };
    function getCurrency(callback) {
        if (venue) {
            return currencyMap[venue.ccy];
        } else {
            return currencyMap["GBP"];
        }
    }
    return {
        getCurrency: getCurrency,
        init: init
    };
} ]);

angular.module("kyc.services").service("UtilsService", [ function() {
    var sliceObject = function(object, begin, end) {
        var i = 0;
        var data = {};
        var keys = Object.keys(object);
        if (keys.length < end) {
            end = keys.length;
        }
        for (var i = begin; i < end; i++) {
            var key = keys[i];
            data[key] = object[key];
        }
        return data;
    };
    var reOrderWidgets = function(element) {
        var $charts = $(element).children().find(".flip-container");
        var objectValues = {};
        for (var i = $charts.length - 1; i >= 0; i--) {
            var $chart = $($charts[i]);
            var index = $charts.index($chart);
            var scope = $chart.scope();
            objectValues[scope.value.num] = {
                order: index,
                display: scope.value.display
            };
            scope.value.order = index;
        }
        window.sessionStorage.setItem("widgets", angular.toJson(objectValues));
    };
    var dynamicSort = function(property, desc) {
        var sortOrder = 1;
        if (desc) {
            sortOrder = -1;
        }
        var result = a[property] < b[property] ? -1 : a[property] > b[property] ? 1 : 0;
        return result * sortOrder;
    };
    var dynamicSortObject = function(obj, property, desc) {
        var sortOrder = 1;
        if (desc) {
            sortOrder = -1;
        }
        var index = [];
        angular.forEach(obj, function(item) {
            index.push(item);
        });
        index.sort(function(a, b) {
            var result = a[property] < b[property] ? -1 : a[property] > b[property] ? 1 : 0;
            return result * sortOrder;
        });
        return index;
    };
    return {
        sliceObject: sliceObject,
        reOrderWidgets: reOrderWidgets,
        dynamicSort: dynamicSort,
        dynamicSortObject: dynamicSortObject
    };
} ]);

"use strict";

angular.module("kyc.controllers").controller("DashboardCtrl", [ "$scope", "$http", "$compile", "ChartType", "$grid", "AllCharts", "$AjaxInterceptor", "$timeout", "$notification", "UtilsService", function($scope, $http, $compile, ChartType, $grid, AllCharts, $AjaxInterceptor, $timeout, $notification, UtilsService) {
    $scope.setLocation("dashboard");
    $scope.$parent.showDateFilter = true;
    var charts = AllCharts.getPreparedCharts();
    $scope.changeVisibility = function(value) {
        if (!value.display) {
            setTimeout(function() {
                angular.element("#removable_" + value.num).triggerHandler("click");
            }, 0);
        } else {
            angular.element("#removable_" + value.num).closest(".flip-container").parent().show();
            UtilsService.reOrderWidgets(angular.element("#sscontainer"));
        }
        angular.element("#sscontainer").trigger("ss-rearrange");
    };
    $scope.shapeshifterConfig = {
        gutterX: 20,
        gutterY: 20,
        paddingX: 0,
        paddingY: 0,
        minColumns: 2
    };
    $scope.values = $grid.populateItems(charts);
    $timeout(function() {
        var isFirstTime = window.sessionStorage.getItem("firsttime_feature_4") === "1";
        if (isFirstTime) {
            window.sessionStorage.setItem("firsttime_feature_4", 0);
            $notification.confirm({
                title: _tr("Welcome to Know Your Customer"),
                content: _tr("From here you can view detailed reports and analytics about your customers and the transactions they make."),
                showTerm: false,
                btnOk: false,
                btnCancel: _tr("GET STARTED"),
                windowClass: "medium"
            });
        }
        $AjaxInterceptor.complete();
        $(window).trigger("resize");
        angular.element("#sscontainer").trigger("ss-rearrange");
    }, 1e3);
} ]);

angular.module("kyc.controllers").controller("CustomersCtrl", [ "$scope", "OrderService", "$AjaxInterceptor", "Export", "ACCOUNT_ID", "UtilsService", function($scope, OrderService, $AjaxInterceptor, Export, ACCOUNT_ID, UtilsService) {
    $scope.setLocation("customers");
    $scope.customers = {};
    $scope.$parent.showDateFilter = true;
    var title = _tr("Customers");
    var allOrders = OrderService.getOrders();
    prepareScopeCustomers();
    $scope.exportAll = "1";
    $scope.selectAll = function() {
        angular.forEach($scope.customers, function(value, key) {
            value.selected = $scope.all_options;
        });
    };
    $scope.exportPdf = function() {
        $scope.pdfData = prepareExportPdfData();
    };
    $scope.exportCsv = function() {
        $scope.csvData = prepareExportCsvData();
    };
    function prepareExportCsvData() {
        var prepData = [ [ $scope.getExportDate() ], [ title ] ];
        angular.forEach($scope.customers, function(item) {
            if ($scope.exportAll === "1" || item.selected === true) {
                prepData.push([ item.name, item.totalSpent, item.emailAddress ]);
            }
        });
        return {
            data: prepData
        };
    }
    function prepareExportPdfData() {
        var prepData = {
            Name: [],
            "Total Spent": [],
            "Email Address": []
        };
        angular.forEach($scope.customers, function(item) {
            if ($scope.exportAll === "1" || item.selected === true) {
                prepData["Name"].push(item.name);
                prepData["Total Spent"].push(item.totalSpent);
                prepData["Email Address"].push(item.emailAddress);
            }
        });
        return {
            title: "Customers",
            startDate: $scope.form.start_date.valueOf(),
            endDate: $scope.form.end_date.valueOf(),
            dataJson: JSON.stringify(prepData)
        };
    }
    function prepareScopeCustomers() {
        if (allOrders) {
            var minDate = moment($scope.$parent.form.start_date);
            var maxDate = moment($scope.$parent.form.end_date);
            angular.forEach(allOrders, function(row) {
                var orderData = moment(row.created);
                if ($scope.$parent.getSelectedOutlets().length === 0 || $scope.$parent.findOutlet(row.outletId).length >= 1) {
                    if (orderData >= minDate && orderData <= maxDate) {
                        var customerId = row.userId;
                        if ($scope.customers[customerId] === undefined) {
                            $scope.customers[customerId] = {
                                name: row.user.firstName + " " + row.user.lastName,
                                totalSpent: Number(row.total.toFixed(2)),
                                emailAddress: row.user.username,
                                marketing: row.user.optinLoyalty || row.user.optinOffers || row.user.optinOther ? _tr("Accepts") : " - "
                            };
                        } else {
                            $scope.customers[customerId].totalSpent = Number(($scope.customers[customerId].totalSpent + row.total).toFixed(2));
                        }
                    }
                }
            });
        }
        $scope.customers = UtilsService.dynamicSortObject($scope.customers, $scope.orderBy, $scope.direction);
        $scope.customersList = $scope.customers;
        $scope.totalItems = Object.keys($scope.customers).length;
        $scope.numPerPage = 10;
        $scope.currentPage = 1;
        $AjaxInterceptor.complete();
    }
    $scope.setOrderBy = function(orderBy, direction) {
        $scope.customers = UtilsService.dynamicSortObject($scope.customers, orderBy, $scope.direction);
        loadCustomersByPage();
    };
    var loadCustomersByPage = function() {
        var begin = ($scope.currentPage - 1) * $scope.numPerPage, end = begin + $scope.numPerPage;
        $scope.customersList = $scope.customers.slice(begin, end);
    };
    $scope.$watch("currentPage + numPerPage", function() {
        loadCustomersByPage();
    });
    $scope.showOptions = function() {
        angular.element(".flip-container").addClass("active");
        setTimeout(function() {
            $(".invisibleBack").addClass("visible");
        }, 200);
    };
    $scope.hideOptions = function() {
        angular.element(".flip-container").removeClass("active");
        setTimeout(function() {
            $(".invisibleBack").removeClass("visible");
        }, 200);
    };
} ]);

angular.module("kyc.controllers").controller("ReportsCtrl", [ "$scope", "$AjaxInterceptor", "OrderService", "Export", "ACCOUNT_ID", "AllReports", "UtilsService", "$filter", function($scope, $AjaxInterceptor, OrderService, Export, ACCOUNT_ID, AllReports, UtilsService, $filter) {
    var orders;
    var title = _tr("Reports");
    $scope.setLocation("reports");
    $scope.exportAll = "1";
    $scope.direction = false;
    $scope.selectAll = function() {
        for (var i = $scope.selectReport.data.length; i--; ) {
            $scope.selectReport.data[i].$selected = $scope.all_options;
        }
    };
    function prepareScopeReports() {
        $scope.reports = AllReports.getReportsList();
        $scope.selectReport($scope.reports[0]);
        if ($scope.selectedReport && $scope.selectedReport.data) {
            $scope.reportsList = $scope.selectedReport.data;
            $scope.totalItems = Object.keys($scope.selectedReport.data).length;
        } else {
            $scope.reportsList = [];
            $scope.totalItems = 0;
        }
        $scope.selectedReport.data = UtilsService.dynamicSortObject($scope.selectedReport.data, $scope.orderBy, $scope.direction);
        $scope.numPerPage = 10;
        $scope.currentPage = 1;
        $AjaxInterceptor.complete();
    }
    $scope.$watch("currentPage + numPerPage", function() {
        loadReportsByPage();
    });
    var loadReportsByPage = function() {
        var begin = ($scope.currentPage - 1) * $scope.numPerPage, end = begin + $scope.numPerPage;
        if ($scope.selectedReport && $scope.selectedReport.data) {
            $scope.reportsList = $scope.selectedReport.data.slice(begin, end);
        }
    };
    $scope.setOrderBy = function(orderBy, direction) {
        $scope.direction = !$scope.direction;
        $scope.orderBy = orderBy;
        $scope.selectedReport.data = UtilsService.dynamicSortObject($scope.selectedReport.data, orderBy, $scope.direction);
        loadReportsByPage();
    };
    $scope.selectReport = function(which) {
        if (which) {
            var report = which;
        } else {
            var report = $scope.reports.filter(function(r) {
                return r.selected === true;
            });
            if (report.length) {
                report = report[0];
            }
        }
        $scope.selectedReport = {
            data: report.getData(),
            title: report.getTitle(),
            titles: report.getTitles()
        };
        $scope.totalItems = Object.keys($scope.selectedReport.data).length;
        $scope.reportsList = UtilsService.sliceObject($scope.selectedReport.data, 0, $scope.numPerPage);
        $scope.currentPage = 1;
        if (report.orderBy) {
            $scope.setOrderBy(report.orderBy);
            $scope.direction = report.direction !== undefined ? report.direction : $scope.direction;
        }
    };
    $scope.getTitle = function(title) {
        return AllReports.getTitle(title);
    };
    function prepareExportPdfData() {
        var prepData = {};
        angular.forEach($scope.selectedReport.data, function(item) {
            if ($scope.exportAll === "1" || item.$selected === true) {
                angular.forEach(item, function(val, prop) {
                    if (prop[0] === "$") return;
                    var propTitle = $scope.getTitle(prop);
                    if (prepData[propTitle] === undefined) {
                        prepData[propTitle] = [];
                    }
                    prepData[propTitle].push(getFilteredProp(val, prop));
                });
            }
        });
        console.log("returning:", {
            title: $scope.selectedReport.title,
            startDate: $scope.form.start_date.valueOf(),
            endDate: $scope.form.end_date.valueOf(),
            dataJson: angular.toJson(prepData)
        });
        return {
            title: $scope.selectedReport.title,
            startDate: $scope.$parent.form.start_date.valueOf(),
            endDate: $scope.$parent.form.end_date.valueOf(),
            dataJson: angular.toJson(prepData)
        };
    }
    function prepareExportCsvData() {
        var prepData = [ [ $scope.getExportDate() ], [ $scope.selectedReport.title ], $scope.selectedReport.titles ];
        angular.forEach($scope.selectedReport.data, function(item) {
            if ($scope.exportAll === "1" || item.$selected === true) {
                var row = [];
                angular.forEach(item, function(val, prop) {
                    if (prop[0] === "$") return;
                    row.push(getFilteredProp(val, prop));
                });
                prepData.push(row);
            }
        });
        return {
            data: prepData
        };
    }
    function getFilteredProp(obj, prop) {
        switch (prop) {
          case "day":
          case "lastOrder":
          case "dateJoined":
          case "dateOfOrder":
          case "date":
            return $filter("date")(obj, "dd/MM/yyyy");

          case "valueSold":
          case "totalSpent":
            return obj.toFixed(2);

          default:
            return obj;
        }
    }
    $scope.exportPdf = function() {
        $scope.pdfData = prepareExportPdfData();
    };
    $scope.exportCsv = function() {
        $scope.csvData = prepareExportCsvData();
    };
    $scope.showOptions = function() {
        angular.element(".flip-container").addClass("active");
        setTimeout(function() {
            $(".invisibleBack").addClass("visible");
        }, 200);
    };
    $scope.hideOptions = function() {
        angular.element(".flip-container").removeClass("active");
        setTimeout(function() {
            $(".invisibleBack").removeClass("visible");
        }, 200);
    };
    prepareScopeReports();
} ]);

angular.module("kyc.controllers").controller("StockCtrl", [ "$scope", "$AjaxInterceptor", "OrderService", "Export", "ACCOUNT_ID", "UtilsService", function($scope, $AjaxInterceptor, OrderService, Export, ACCOUNT_ID, UtilsService) {
    var title = _tr("Stock");
    $scope.setLocation("stock");
    $scope.$parent.showDateFilter = true;
    $scope.stock = {};
    $scope.exportAll = "1";
    var allOrders = OrderService.getOrders();
    $scope.selectAll = function() {
        angular.forEach($scope.stock, function(value, key) {
            value.selected = $scope.all_options;
        });
    };
    $scope.exportPdf = function() {
        $scope.pdfData = prepareExportPdfData();
    };
    $scope.exportCsv = function() {
        $scope.csvData = prepareExportCsvData();
    };
    function prepareExportCsvData(type) {
        var prepData = [ [ $scope.getExportDate() ], [ title ] ];
        angular.forEach($scope.stock, function(item) {
            if ($scope.exportAll === "1" || item.selected === true) {
                prepData.push([ item.name, item.quantity ]);
            }
        });
        return {
            data: prepData
        };
    }
    function prepareExportPdfData() {
        var prepData = {
            Item: [],
            "Quantity Ordered": []
        };
        angular.forEach($scope.stock, function(item) {
            if ($scope.exportAll === "1" || item.selected === true) {
                prepData["Item"].push(item.name);
                prepData["Quantity Ordered"].push(item.quantity);
            }
        });
        return {
            title: "Stock",
            startDate: $scope.form.start_date.valueOf(),
            endDate: $scope.form.end_date.valueOf(),
            dataJson: JSON.stringify(prepData)
        };
    }
    function prepareScopeStock() {
        if (allOrders) {
            var minDate = moment($scope.$parent.form.start_date);
            var maxDate = moment($scope.$parent.form.end_date);
            angular.forEach(allOrders, function(row) {
                var orderData = moment(row.created);
                console.log("row outletId ", row.outletId);
                console.log("parent: outletId ", $scope.$parent.outlets);
                if ($scope.$parent.getSelectedOutlets().length === 0 || $scope.$parent.findOutlet(row.outletId).length >= 1) {
                    if (orderData >= minDate && orderData <= maxDate) {
                        angular.forEach(row.items, function(item) {
                            var itemId = item.menuItemId;
                            if ($scope.stock[itemId] === undefined) {
                                $scope.stock[itemId] = {
                                    name: item.name,
                                    quantity: item.qty
                                };
                            } else {
                                $scope.stock[itemId].quantity += item.qty;
                            }
                        });
                    }
                }
            });
        }
        $scope.stock = UtilsService.dynamicSortObject($scope.stock, $scope.orderBy, $scope.direction);
        $scope.stocks = $scope.stock;
        $scope.totalItems = Object.keys($scope.stock).length;
        $scope.numPerPage = 10;
        $scope.currentPage = 1;
        $AjaxInterceptor.complete();
    }
    $scope.setOrderBy = function(orderBy, direction) {
        $scope.stock = UtilsService.dynamicSortObject($scope.stock, orderBy, $scope.direction);
        loadStocksByPage();
    };
    var loadStocksByPage = function() {
        var begin = ($scope.currentPage - 1) * $scope.numPerPage, end = begin + $scope.numPerPage;
        $scope.stocks = $scope.stock.slice(begin, end);
    };
    $scope.$watch("currentPage + numPerPage", function() {
        loadStocksByPage();
    });
    prepareScopeStock();
    $scope.setPage = function(pageNo) {
        $scope.currentPage = pageNo;
    };
    $scope.showOptions = function() {
        angular.element(".flip-container").addClass("active");
        setTimeout(function() {
            $(".invisibleBack").addClass("visible");
        }, 200);
    };
    $scope.hideOptions = function() {
        angular.element(".flip-container").removeClass("active");
        setTimeout(function() {
            $(".invisibleBack").removeClass("visible");
        }, 100);
    };
} ]);

angular.module("kyc.controllers").controller("StreamCtrl", [ "$scope", "OrderService", "pusher", "$AjaxInterceptor", "$interval", "VENUE_ID", function($scope, OrderService, pusher, $AjaxInterceptor, $interval, VENUE_ID) {
    $scope.$parent.showDateFilter = false;
    $scope.setLocation("stream");
    $scope.orders = OrderService.getOrders();
    var onTimeout = false;
    var pusherUpdateEvent = function() {
        if (!onTimeout) {
            onTimeout = true;
            OrderService.load(function(orders) {
                $scope.orders = orders;
            });
            setTimeout(function() {
                onTimeout = false;
            }, 500);
        }
    };
    pusher.reset();
    var venueId = VENUE_ID;
    var selectedOutlets = $scope.getSelectedOutlets();
    var outletIds = [];
    angular.forEach(selectedOutlets, function(outlet) {
        outletIds.push(outlet.id);
    });
    pusher.bind(venueId, outletIds, pusherUpdateEvent);
    $scope.getStatusName = function(status) {
        var statusMap = {
            PAYMENT_FAILED: "FAILED",
            NOSHOW: "NO SHOW"
        };
        return statusMap[status] ? statusMap[status] : status;
    };
    $scope.getStatusColor = function(status) {
        switch (status) {
          case "PENDING":
          case "ACCEPTED":
          case "PREPARING":
          case "READY":
          case "DELIVERING":
          case "COMPLETED":
            return "good";

          case "NOSHOW":
          case "REJECTED":
          case "CANCELLED":
          case "PAYMENT_FAILED":
          default:
            return "bad";
        }
    };
    $scope.outletFilter = function(order) {
        return outletIds && outletIds.length === 0 || outletIds.indexOf(order.outletId) > -1;
    };
    $scope.showOptions = function() {
        angular.element(".flip-container").addClass("active");
    };
    $scope.hideOptions = function() {
        angular.element(".flip-container").removeClass("active");
    };
    $scope.activeStream = function(stream) {
        var result = $scope.orders.filter(function(item) {
            return item.active === true;
        });
        if (result && result[0] && result[0].code != stream.code) {
            result[0].active = false;
        }
        stream.active = !stream.active;
    };
    $scope.getOrderItems = function(order) {
        var items = [];
        angular.forEach(order.items, function(item) {
            items.push(item.qty + " x " + item.name);
        });
        return items;
    };
    $AjaxInterceptor.complete();
} ]);

angular.module("kyc.controllers").controller("MenuCtrl", [ "$scope", "OutletService", "OrderService", "AllCharts", "$route", "VenueService", "$AjaxInterceptor", "$location", function($scope, OutletService, OrderService, AllCharts, $route, VenueService, $AjaxInterceptor, $location) {
    $scope.currencySymbol = "%C2%A3";
    $scope.outlets = [];
    $scope.form = {
        start_date: moment().subtract("month", 3),
        end_date: moment()
    };
    $scope.getCurrency = function() {
        return decodeURI($scope.currencySymbol);
    };
    VenueService.init().then(function(venue) {
        $scope.venue = venue;
        $scope.currencySymbol = VenueService.getCurrency().symbol;
        OutletService.init(function() {
            $scope.outlets = OutletService.getOutlets();
            AllCharts.init($scope.form.start_date, $scope.form.end_date, $scope.currencySymbol);
        });
    });
    $scope.update = function() {
        $AjaxInterceptor.start();
        console.log("updating", $scope.form.start_date, $scope.form.end_date);
        setTimeout(function() {
            AllCharts.init($scope.form.start_date, $scope.form.end_date, $scope.currencySymbol, $scope.getSelectedOutlets());
            $route.reload();
            $AjaxInterceptor.complete();
        }, 500);
    };
    $scope.setLocation = function(newLocation) {
        $scope.currentLocation = newLocation;
        if ($location.path() !== "/" + newLocation) $location.path(newLocation);
    };
    $scope.getSelectedOutlets = function() {
        return $scope.outlets.filter(function(data) {
            return data.selected === true;
        });
    };
    $scope.findOutlet = function(id) {
        return $scope.outlets.filter(function(data) {
            return data.selected === true && data.id === id;
        });
    };
    $scope.getExportDate = function() {
        return $scope.form.start_date.format("DD-MMM-YYYY") + " - " + $scope.form.end_date.format("DD-MMM-YYYY");
    };
} ]);

angular.module("kyc.resources").factory("Export", [ "$resource", function($resource) {
    var Pdf = $resource("/api/accounts/:accountId/exports/pdf", {
        accountId: "@accountId"
    }, {
        table: {
            method: "POST",
            url: "/api/accounts/:accountId/exports/pdf/table"
        },
        chart: {
            method: "POST",
            url: "/api/accounts/:accountId/exports/pdf/table"
        }
    });
    var Csv = $resource("/api/accounts/:accountId/exports/csv", {
        accountId: "@accountId"
    }, {});
    var TablePdf = $resource("/api/accounts/:accountId/exports/table/pdf", {
        accountId: "@accountId"
    }, {});
    return {
        Pdf: Pdf,
        Csv: Csv,
        TablePdf: TablePdf
    };
} ]);

angular.module("kyc.resources").factory("Outlet", [ "$resource", function($resource) {
    var Outlet = $resource("/api/outlets", {}, {});
    return Outlet;
} ]);

angular.module("kyc.resources").factory("Order", [ "$resource", function($resource) {
    var Order = $resource("/api/orders", {}, {});
    return Order;
} ]);

angular.module("kyc.resources").factory("Venue", [ "$resource", function($resource) {
    var Venue = $resource("/api/venues/:id", {}, {
        query: {
            method: "GET",
            isArray: true
        }
    });
    return Venue;
} ]);

angular.module("kyc.resources").factory("VenueCustomers", [ "$resource", function($resource) {
    var VenueCustomers = $resource("/api/venues/:id/customers", {
        id: "@id"
    }, {});
    return VenueCustomers;
} ]);

angular.module("kyc.resources").factory("Report", [ "$resource", function($resource) {
    var Report = $resource("/api/reports/:venueId", {
        venueId: "@venueId"
    }, {
        items: {
            method: "GET",
            isArray: true,
            url: "/api/reports/:venueId/items"
        },
        orders: {
            method: "GET",
            isArray: true,
            url: "/api/reports/:venueId/orders"
        },
        customerOrders: {
            method: "GET",
            isArray: true,
            url: "/api/reports/:venueId/customerOrders"
        }
    });
    return Report;
} ]);

angular.module("kyc").constant("ChartType", {
    NUMBER: "NUMBER",
    COLUMN: "COLUMN",
    PIE: "PIE",
    AREA: "AREA",
    AREA_MODAL: "AREA_MODAL"
});

angular.module("kyc").constant("Colors", [ "#18a4dd", "#1576b7", "#543b87", "#392654", "#f5b23e", "#8bbf4f", "#c0392b", "#46545d", "#b4b6b8", "#dcdddf" ]);

angular.module("kyc").constant("TickInterval", {
    DAY: 24 * 3600 * 1e3,
    WEEK: 7 * 24 * 3600 * 1e3,
    WEEK_THREE: 3 * 7 * 24 * 3600 * 1e3,
    MONTH: 30 * 24 * 3600 * 1e3
});

"use strict";

angular.module("kyc.directives").directive("chart", [ "$modal", "ChartType", "$chartService", "Export", "ACCOUNT_ID", "UtilsService", function($modal, ChartType, $chartService, Export, ACCOUNT_ID, UtilsService) {
    return {
        templateUrl: "/code/kyc/js/directives/chart/chart.php",
        restrict: "E",
        replace: true,
        scope: {
            chart: "=element"
        },
        link: function(ng, elem, attrs) {
            if (!ng.chart.display) {
                elem.parent().hide();
            }
            ng.noData = false;
            function setNoData() {
                if (ng.chart.showChart) {
                    switch (ng.chart.value.type) {
                      case ChartType.PIE:
                      case ChartType.COLUMN:
                        if (ng.chart.value.data.length === 0) {
                            ng.noData = true;
                        } else {
                            var allZero = true;
                            angular.forEach(ng.chart.value.data, function(data) {
                                if (data.y > 0) allZero = false;
                            });
                            ng.noData = allZero;
                        }
                        break;

                      case ChartType.AREA:
                        if (ng.chart.value.data.length <= 1) {
                            ng.noData = true;
                        }
                        break;
                    }
                } else {
                    if (ng.chart.value === 0 || ng.chart.value === "NaN" || ng.chart.value == NaN) {
                        ng.noData = true;
                    }
                }
            }
            setNoData();
            ng.ChartType = ChartType;
            var $actionsChart = elem.find(".actions-chart");
            var $chart = elem.find(".chart");
            var $flipContainer = elem.closest(".flip-container");
            refreshChart();
            function openModal() {
                if (ng.chart.value.modal) {
                    var w = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
                    var windowClass = w > 1300 ? "large" : "xlarge";
                    var mod = $modal.open({
                        templateUrl: modal_url("chart"),
                        windowClass: windowClass + " modal-preoday modal-chart",
                        controller: function($scope) {
                            $scope.optionHasData = function(option) {
                                return option.data.length > 1 && +option.value > 0 ? 1 : 0;
                            };
                            $scope.noData = false;
                            $scope.chart = angular.copy(ng.chart);
                            if (ng.chart.value.modal.highcharts) {
                                var firstOption = ng.chart.value.modal.options[0];
                                ng.chart.value.tickInterval = firstOption.tickInterval;
                                ng.chart.value.minTimestamp = moment(firstOption.minTimestamp).valueOf();
                                ng.chart.value.maxTimestamp = moment(firstOption.maxTimestamp).valueOf();
                                var value = angular.copy(ng.chart.value);
                                value.data = firstOption.data;
                                $scope.chart.highcharts = $chartService.getChart(ng.chart.value.modal.highcharts.type, value);
                            }
                            $scope.showOptions = function() {
                                $(".modal-chart .flip-container").addClass("active");
                                setTimeout(function() {
                                    $(".modal-chart .invisibleBack").addClass("visible");
                                }, 200);
                            };
                            $scope.hideOptions = function() {
                                $(".modal-chart .flip-container").removeClass("active");
                                setTimeout(function() {
                                    $(".modal-chart .invisibleBack").removeClass("visible");
                                }, 200);
                            };
                            $scope.cancel = function() {
                                mod.close();
                            };
                            $scope.title = ng.chart.title;
                            $scope.selectOption = function(option) {
                                $scope.noData = false;
                                var itemActive = $scope.chart.value.modal.options.filter(function(item) {
                                    return item.active == true;
                                });
                                if (itemActive) {
                                    itemActive[0].active = false;
                                }
                                option.active = true;
                                $scope.chart.highcharts = $chartService.getChart(ng.chart.value.modal.highcharts.type, {
                                    tooltipText: ng.chart.value.tooltipText,
                                    data: option.data,
                                    tickInterval: option.tickInterval,
                                    minTimestamp: moment(option.minTimestamp).valueOf(),
                                    maxTimestamp: moment(option.maxTimestamp).valueOf()
                                });
                            };
                            $scope.setNoData = function(option) {
                                $scope.noData = true;
                                var itemActive = $scope.chart.value.modal.options.filter(function(item) {
                                    return item.active == true;
                                });
                                if (itemActive) {
                                    itemActive[0].active = false;
                                }
                                option.active = true;
                            };
                        }
                    });
                    mod.opened.then(function() {
                        setTimeout(function() {
                            $(".modal-preoday").addClass("active");
                        }, 1);
                    });
                }
            }
            ng.showOptions = function() {
                $flipContainer.addClass("active");
                setTimeout(function() {
                    elem.find(".invisibleBack").addClass("visible");
                }, 200);
            };
            ng.hideOptions = function() {
                $flipContainer.removeClass("active");
                setTimeout(function() {
                    elem.find(".invisibleBack").removeClass("visible");
                }, 100);
            };
            ng.removeGrid = function(chart, $event) {
                chart.display = false;
                elem.parent().hide();
                UtilsService.reOrderWidgets(elem.closest(".sscontainer"));
            };
            ng.changeItem = function(item) {
                var items = ng.chart.value.items.filter(function(i) {
                    return i.selected === true;
                });
                if (items.length) {
                    ng.selectedItem = items[0];
                    ng.selectedItem.callback(ng.selectedItem.menuItemId, function(highchart) {
                        ng.chart.value = highchart;
                        refreshChart();
                    });
                }
            };
            ng.exportPdf = function() {
                ng.pdfData = ng.chart.value.getPdf();
            };
            ng.exportCsv = function() {
                ng.csvData = ng.chart.value.getCsv();
            };
            ng.getText = function(chart) {
                if (typeof chart.value === "object") {
                    var strNum = chart.value.numberLeft;
                } else {
                    var strNum = chart.value.toLocaleString();
                }
                if (chart.currency) {
                    return decodeURI(chart.currency) + strNum;
                } else return strNum;
            };
            function refreshChart() {
                var highchartsConfig = $chartService.getChart(ng.chart.value.type, ng.chart.value);
                if (ng.chart.value.items) {
                    highchartsConfig.options.chart.height = 205;
                    elem.parent().addClass("highchartsItem");
                }
                if (ng.chart.value.type === ChartType.AREA) {
                    highchartsConfig.options.chart.events = {
                        click: openModal
                    };
                }
                ng.chart.highcharts = highchartsConfig;
            }
        }
    };
} ]);

"use strict";

angular.module("kyc.directives").factory("highchartsNGUtils", function() {
    return {
        indexOf: function(arr, find, i) {
            if (i === undefined) i = 0;
            if (i < 0) i += arr.length;
            if (i < 0) i = 0;
            for (var n = arr.length; i < n; i++) if (i in arr && arr[i] === find) return i;
            return -1;
        },
        prependMethod: function(obj, method, func) {
            var original = obj[method];
            obj[method] = function() {
                var args = Array.prototype.slice.call(arguments);
                func.apply(this, args);
                if (original) {
                    return original.apply(this, args);
                } else {
                    return;
                }
            };
        },
        deepExtend: function deepExtend(destination, source) {
            if (angular.isArray(source)) {
                destination = angular.isArray(destination) ? destination : [];
                for (var i = 0; i < source.length; i++) {
                    destination[i] = deepExtend(destination[i] || {}, source[i]);
                }
            } else if (angular.isObject(source)) {
                for (var property in source) {
                    destination[property] = deepExtend(destination[property] || {}, source[property]);
                }
            } else {
                destination = source;
            }
            return destination;
        }
    };
}).directive("highchart", [ "highchartsNGUtils", function(highchartsNGUtils) {
    var seriesId = 0;
    var ensureIds = function(series) {
        var changed = false;
        angular.forEach(series, function(s) {
            if (!angular.isDefined(s.id)) {
                s.id = "series-" + seriesId++;
                changed = true;
            }
        });
        return changed;
    };
    var axisNames = [ "xAxis", "yAxis" ];
    var getMergedOptions = function(scope, element, config) {
        var mergedOptions = {};
        var defaultOptions = {
            chart: {
                events: {}
            },
            title: {},
            subtitle: {},
            series: [],
            credits: {},
            plotOptions: {},
            navigator: {
                enabled: false
            }
        };
        if (config.options) {
            mergedOptions = highchartsNGUtils.deepExtend(defaultOptions, config.options);
        } else {
            mergedOptions = defaultOptions;
        }
        mergedOptions.chart.renderTo = element[0];
        angular.forEach(axisNames, function(axisName) {
            if (angular.isDefined(config[axisName])) {
                mergedOptions[axisName] = angular.copy(config[axisName]);
                if (angular.isDefined(config[axisName].currentMin) || angular.isDefined(config[axisName].currentMax)) {
                    highchartsNGUtils.prependMethod(mergedOptions.chart.events, "selection", function(e) {
                        var thisChart = this;
                        if (e[axisName]) {
                            scope.$apply(function() {
                                scope.config[axisName].currentMin = e[axisName][0].min;
                                scope.config[axisName].currentMax = e[axisName][0].max;
                            });
                        } else {
                            scope.$apply(function() {
                                scope.config[axisName].currentMin = thisChart[axisName][0].dataMin;
                                scope.config[axisName].currentMax = thisChart[axisName][0].dataMax;
                            });
                        }
                    });
                    highchartsNGUtils.prependMethod(mergedOptions.chart.events, "addSeries", function(e) {
                        scope.config[axisName].currentMin = this[axisName][0].min || scope.config[axisName].currentMin;
                        scope.config[axisName].currentMax = this[axisName][0].max || scope.config[axisName].currentMax;
                    });
                }
            }
        });
        if (config.title) {
            mergedOptions.title = config.title;
        }
        if (config.subtitle) {
            mergedOptions.subtitle = config.subtitle;
        }
        if (config.credits) {
            mergedOptions.credits = config.credits;
        }
        if (config.size) {
            if (config.size.width) {
                mergedOptions.chart.width = config.size.width;
            }
            if (config.size.height) {
                mergedOptions.chart.height = config.size.height;
            }
        }
        return mergedOptions;
    };
    var updateZoom = function(axis, modelAxis) {
        var extremes = axis.getExtremes();
        if (modelAxis.currentMin !== extremes.dataMin || modelAxis.currentMax !== extremes.dataMax) {
            axis.setExtremes(modelAxis.currentMin, modelAxis.currentMax, false);
        }
    };
    var processExtremes = function(chart, axis, axisName) {
        if (axis.currentMin || axis.currentMax) {
            chart[axisName][0].setExtremes(axis.currentMin, axis.currentMax, true);
        }
    };
    var chartOptionsWithoutEasyOptions = function(options) {
        return angular.extend({}, options, {
            data: null,
            visible: null
        });
    };
    return {
        restrict: "EAC",
        replace: true,
        template: "<div></div>",
        scope: {
            config: "="
        },
        link: function(scope, element, attrs) {
            var prevSeriesOptions = {};
            var processSeries = function(series) {
                var i;
                var ids = [];
                if (series) {
                    var setIds = ensureIds(series);
                    if (setIds) {
                        return false;
                    }
                    angular.forEach(series, function(s) {
                        ids.push(s.id);
                        var chartSeries = chart.get(s.id);
                        if (chartSeries) {
                            if (!angular.equals(prevSeriesOptions[s.id], chartOptionsWithoutEasyOptions(s))) {
                                chartSeries.update(angular.copy(s), false);
                            } else {
                                if (s.visible !== undefined && chartSeries.visible !== s.visible) {
                                    chartSeries.setVisible(s.visible, false);
                                }
                                chartSeries.setData(angular.copy(s.data), false);
                            }
                        } else {
                            chart.addSeries(angular.copy(s), false);
                        }
                        prevSeriesOptions[s.id] = chartOptionsWithoutEasyOptions(s);
                    });
                    if (scope.config.noData) {
                        var chartContainsData = false;
                        for (i = 0; i < series.length; i++) {
                            if (series[i].data && series[i].data.length > 0) {
                                chartContainsData = true;
                                break;
                            }
                        }
                        if (!chartContainsData) {
                            chart.showLoading(scope.config.noData);
                        } else {
                            chart.hideLoading();
                        }
                    }
                }
                for (i = chart.series.length - 1; i >= 0; i--) {
                    var s = chart.series[i];
                    if (highchartsNGUtils.indexOf(ids, s.options.id) < 0) {
                        s.remove(false);
                    }
                }
                return true;
            };
            var chart = false;
            var initChart = function() {
                if (chart) chart.destroy();
                prevSeriesOptions = {};
                var config = scope.config || {};
                var mergedOptions = getMergedOptions(scope, element, config);
                chart = config.useHighStocks ? new Highcharts.StockChart(mergedOptions) : new Highcharts.Chart(mergedOptions);
                for (var i = 0; i < axisNames.length; i++) {
                    if (config[axisNames[i]]) {
                        processExtremes(chart, config[axisNames[i]], axisNames[i]);
                    }
                }
                if (config.loading) {
                    chart.showLoading();
                }
            };
            initChart();
            scope.$watch("config.series", function(newSeries, oldSeries) {
                var needsRedraw = processSeries(newSeries);
                if (needsRedraw) {
                    chart.redraw();
                }
            }, true);
            scope.$watch("config.title", function(newTitle) {
                chart.setTitle(newTitle, true);
            }, true);
            scope.$watch("config.subtitle", function(newSubtitle) {
                chart.setTitle(true, newSubtitle);
            }, true);
            scope.$watch("config.loading", function(loading) {
                if (loading) {
                    chart.showLoading();
                } else {
                    chart.hideLoading();
                }
            });
            scope.$watch("config.credits.enabled", function(enabled) {
                if (enabled) {
                    chart.credits.show();
                } else if (chart.credits) {
                    chart.credits.hide();
                }
            });
            scope.$watch("config.useHighStocks", function(useHighStocks, oldUseHighStocks) {
                if (useHighStocks === oldUseHighStocks) return;
                initChart();
            });
            angular.forEach(axisNames, function(axisName) {
                scope.$watch("config." + axisName, function(newAxes, oldAxes) {
                    if (newAxes === oldAxes) return;
                    if (newAxes) {
                        chart[axisName][0].update(newAxes, false);
                        updateZoom(chart[axisName][0], angular.copy(newAxes));
                        chart.redraw();
                    }
                }, true);
            });
            scope.$watch("config.options", function(newOptions, oldOptions, scope) {
                if (newOptions === oldOptions) return;
                initChart();
                processSeries(scope.config.series);
                chart.redraw();
            }, true);
            scope.$watch("config.size", function(newSize, oldSize) {
                if (newSize === oldSize) return;
                if (newSize) {
                    chart.setSize(newSize.width || undefined, newSize.height || undefined);
                }
            }, true);
            scope.$on("highchartsng.reflow", function() {
                chart.reflow();
            });
            scope.$on("$destroy", function() {
                if (chart) chart.destroy();
                element.remove();
            });
        }
    };
} ]);

"use strict";

angular.module("kyc.directives").directive("datepicker", [ "$parse", "$filter", function($parse, $filter) {
    return {
        restrict: "A",
        require: "ngModel",
        scope: {
            compareStart: "=start",
            compareEnd: "=end"
        },
        link: function(ng, elem, attrs, ngModel) {
            elem.fdatepicker({
                format: "dd/mm/yyyy",
                onRender: function(date) {
                    if (ng.compareStart) {
                        var isBeforeStart = date.valueOf() < ng.compareStart.valueOf() || date.valueOf() > moment().valueOf();
                        return isBeforeStart ? "disabled" : "";
                    } else if (ng.compareEnd) {
                        var isAfterEnd = date.valueOf() > ng.compareEnd.valueOf();
                        return isAfterEnd ? "disabled" : "";
                    }
                }
            }).on("changeDate", function(ev) {
                ng.$apply(function(scope) {
                    ngModel.$setViewValue(ev.date);
                    elem.fdatepicker("setDate", ev.date);
                });
            });
            ngModel.$parsers.push(function(data) {
                if (typeof data === "string") {
                    var dataArr = data.split("/");
                    return moment([ dataArr[2], +dataArr[1] - 1, +dataArr[0] ]);
                } else {
                    return moment(data);
                }
            });
            ngModel.$formatters.push(function(data) {
                return data.format("DD/MM/YYYY");
            });
        }
    };
} ]);

angular.module("kyc.directives").directive("multiSelect", [ "$sce", "$filter", function($sce, $filter) {
    return {
        restrict: "AE",
        replace: true,
        scope: {
            inputModel: "=",
            outputModel: "=",
            buttonLabel: "@",
            selectionMode: "@",
            itemLabel: "@",
            tickProperty: "@",
            disableProperty: "@",
            orientation: "@",
            defaultLabel: "@",
            maxLabels: "@",
            isDisabled: "=",
            directiveId: "@",
            helperElements: "@",
            onOpen: "&",
            onClose: "&",
            onBlur: "&",
            onFocus: "&",
            onChange: "&"
        },
        templateUrl: directive_url("multiselect/multiselect.htm"),
        link: function($scope, element, attrs) {
            $scope.selectedItems = [];
            $scope.backUp = [];
            $scope.varButtonLabel = "";
            $scope.currentButton = null;
            $scope.scrolled = false;
            $scope.displayHelper = function(elementString) {
                if (typeof attrs.helperElements === "undefined") {
                    return true;
                }
                switch (elementString.toUpperCase()) {
                  case "ALL":
                    if (attrs.selectionMode && $scope.selectionMode.toUpperCase() === "SINGLE") {
                        return false;
                    } else {
                        if (attrs.helperElements && $scope.helperElements.toUpperCase().indexOf("ALL") >= 0) {
                            return true;
                        }
                    }
                    break;

                  case "NONE":
                    if (attrs.selectionMode && $scope.selectionMode.toUpperCase() === "SINGLE") {
                        return false;
                    } else {
                        if (attrs.helperElements && $scope.helperElements.toUpperCase().indexOf("NONE") >= 0) {
                            return true;
                        }
                    }
                    break;

                  case "RESET":
                    if (attrs.helperElements && $scope.helperElements.toUpperCase().indexOf("RESET") >= 0) {
                        return true;
                    }
                    break;

                  case "FILTER":
                    if (attrs.helperElements && $scope.helperElements.toUpperCase().indexOf("FILTER") >= 0) {
                        return true;
                    }
                    break;

                  default:
                    break;
                }
            };
            $scope.syncItems = function(item, e) {
                index = $scope.inputModel.indexOf(item);
                $scope.inputModel[index][$scope.tickProperty] = !$scope.inputModel[index][$scope.tickProperty];
                if (attrs.selectionMode && $scope.selectionMode.toUpperCase() === "SINGLE") {
                    $scope.inputModel[index][$scope.tickProperty] = true;
                    for (var i = 0; i < $scope.inputModel.length; i++) {
                        if (i !== index) {
                            $scope.inputModel[i][$scope.tickProperty] = false;
                        }
                    }
                    $scope.toggleCheckboxes(e);
                }
                $scope.refreshSelectedItems();
                if (attrs.selectionMode && $scope.selectionMode.toUpperCase() === "SINGLE") {
                    $scope.toggleCheckboxes(e);
                } else {
                    e.target.focus();
                }
                $scope.onChange();
            };
            $scope.refreshSelectedItems = function() {
                $scope.varButtonLabel = "";
                $scope.selectedItems = [];
                var ctr = 0;
                angular.forEach($scope.inputModel, function(value, key) {
                    if (typeof value !== "undefined") {
                        if (value[$scope.tickProperty] === true || value[$scope.tickProperty] === "true") {
                            $scope.selectedItems.push(value);
                        }
                    }
                });
                if (typeof attrs.outputModel !== "undefined") {
                    $scope.outputModel = angular.copy($scope.selectedItems);
                }
                if ($scope.selectedItems.length === 0) {
                    $scope.varButtonLabel = $scope.defaultLabel ? $scope.defaultLabel : "None selected";
                } else {
                    var tempMaxLabels = $scope.selectedItems.length;
                    if (typeof $scope.maxLabels !== "undefined" && $scope.maxLabels !== "") {
                        tempMaxLabels = $scope.maxLabels;
                    }
                    if ($scope.selectedItems.length > tempMaxLabels) {
                        $scope.more = true;
                    } else {
                        $scope.more = false;
                    }
                    angular.forEach($scope.selectedItems, function(value, key) {
                        if (typeof value !== "undefined") {
                            if (ctr < tempMaxLabels) {
                                $scope.varButtonLabel += ($scope.varButtonLabel.length > 0 ? ", " : "") + $scope.writeLabel(value, "buttonLabel");
                            }
                            ctr++;
                        }
                    });
                    if ($scope.more === true) {
                        if (tempMaxLabels > 0) {
                            $scope.varButtonLabel += ", ... ";
                        }
                        $scope.varButtonLabel += "(Total: " + $scope.selectedItems.length + ")";
                    }
                }
            };
            $scope.itemIsDisabled = function(item) {
                if (item[$scope.disableProperty] === true) {
                    return true;
                } else {
                    $scope;
                    if ($scope.isDisabled === true) {
                        return true;
                    } else {
                        return false;
                    }
                }
            };
            $scope.writeLabel = function(item, type) {
                var label = "";
                var temp = $scope[type].split(" ");
                angular.forEach(temp, function(value2, key2) {
                    if (typeof value2 !== "undefined") {
                        angular.forEach(item, function(value1, key1) {
                            if (key1 == value2) {
                                label += " " + value1;
                            }
                        });
                    }
                });
                return $sce.trustAsHtml(label);
            };
            $scope.toggleCheckboxes = function(e) {
                if (e.target) {
                    if (e.target.tagName.toUpperCase() !== "BUTTON" && e.target.className.indexOf("multiSelectButton") < 0) {
                        if (attrs.selectionMode && $scope.selectionMode.toUpperCase() === "SINGLE") {
                            if (e.target.tagName.toUpperCase() === "INPUT") {
                                e = $scope.findUpTag(e.target, "div", "checkboxLayer");
                                e = e.previousSibling;
                            }
                        } else {
                            e = $scope.findUpTag(e.target, "button", "multiSelectButton");
                        }
                    } else {
                        e = e.target;
                    }
                }
                $scope.labelFilter = "";
                var multiSelectIndex = -1;
                var checkboxes = document.querySelectorAll(".checkboxLayer");
                var multiSelectButtons = document.querySelectorAll(".multiSelectButton");
                for (var i = 0; i < multiSelectButtons.length; i++) {
                    if (e === multiSelectButtons[i]) {
                        multiSelectIndex = i;
                        break;
                    }
                }
                if (multiSelectIndex > -1) {
                    for (var i = 0; i < checkboxes.length; i++) {
                        if (i != multiSelectIndex) {
                            checkboxes[i].className = "multiSelect checkboxLayer hide";
                        }
                    }
                    if (checkboxes[multiSelectIndex].className == "multiSelect checkboxLayer hide") {
                        $scope.currentButton = multiSelectButtons[multiSelectIndex];
                        checkboxes[multiSelectIndex].className = "multiSelect checkboxLayer dropdown pdDropdown show";
                        $scope.onOpen();
                    } else if (checkboxes[multiSelectIndex].className == "multiSelect checkboxLayer dropdown pdDropdown show") {
                        checkboxes[multiSelectIndex].className = "multiSelect checkboxLayer hide";
                        $scope.onClose();
                    }
                }
            };
            $scope.findUpTag = function(el, tag, className) {
                while (el.parentNode) {
                    el = el.parentNode;
                    if (typeof el.tagName !== "undefined") {
                        if (el.tagName.toUpperCase() === tag.toUpperCase() && el.className.indexOf(className) > -1) {
                            return el;
                        }
                    }
                }
                return null;
            };
            $scope.select = function(type) {
                var temp = [];
                switch (type.toUpperCase()) {
                  case "ALL":
                    angular.forEach($scope.inputModel, function(value, key) {
                        if (typeof value !== "undefined" && value[$scope.disableProperty] !== true) {
                            value[$scope.tickProperty] = true;
                        }
                    });
                    break;

                  case "NONE":
                    angular.forEach($scope.inputModel, function(value, key) {
                        if (typeof value !== "undefined" && value[$scope.disableProperty] !== true) {
                            value[$scope.tickProperty] = false;
                        }
                    });
                    break;

                  case "RESET":
                    $scope.inputModel = angular.copy($scope.backUp);
                    break;

                  default:                }
                $scope.refreshSelectedItems();
            };
            var validate = function() {
                if (!("inputModel" in attrs)) {
                    console.log("Multi-select error: input-model is not defined! (ID: " + $scope.directiveId + ")");
                }
                if (!("buttonLabel" in attrs)) {
                    console.log("Multi-select error: button-label is not defined! (ID: " + $scope.directiveId + ")");
                }
                if (!("itemLabel" in attrs)) {
                    console.log("Multi-select error: item-label is not defined! (ID: " + $scope.directiveId + ")");
                }
                if (!("tickProperty" in attrs)) {
                    console.log("Multi-select error: tick-property is not defined! (ID: " + $scope.directiveId + ")");
                }
            };
            var validateProperties = function(arrProperties, arrObject) {
                var notThere = false;
                var missingProperty = "";
                angular.forEach(arrProperties, function(value1, key1) {
                    if (typeof value1 !== "undefined") {
                        var keepGoing = true;
                        angular.forEach(arrObject, function(value2, key2) {
                            if (typeof value2 !== "undefined" && keepGoing) {
                                if (!(value1 in value2)) {
                                    notThere = true;
                                    keepGoing = false;
                                    var missingLabel = value1;
                                }
                            }
                        });
                    }
                });
                if (notThere === true) {}
            };
            validate();
            $scope.refreshSelectedItems();
            $scope.$watch("inputModel", function(oldVal, newVal) {
                if ($scope.newVal !== "undefined") {
                    validateProperties($scope.itemLabel.split(" "), $scope.inputModel);
                    validateProperties(new Array($scope.tickProperty), $scope.inputModel);
                }
                $scope.refreshSelectedItems();
            }, true);
            $scope.$watch("inputModel", function(oldVal, newVal) {
                if ($scope.newVal !== "undefined") {
                    validateProperties($scope.itemLabel.split(" "), $scope.inputModel);
                    validateProperties(new Array($scope.tickProperty), $scope.inputModel);
                }
                $scope.backUp = angular.copy($scope.inputModel);
                $scope.refreshSelectedItems();
            });
            $scope.$watch("isDisabled", function(newVal) {
                $scope.isDisabled = newVal;
            });
            angular.element(document).bind("touchstart", function(e) {
                $scope.$apply(function() {
                    $scope.scrolled = false;
                });
            });
            angular.element(document).bind("touchmove", function(e) {
                $scope.$apply(function() {
                    $scope.scrolled = true;
                });
            });
            angular.element(document).bind("click touchend", function(e) {
                if (e.type === "click" || e.type === "touchend" && $scope.scrolled === false) {
                    var checkboxes = document.querySelectorAll(".checkboxLayer");
                    if (e.target.className.indexOf === undefined || e.target.className.indexOf("multiSelect")) {
                        for (var i = 0; i < checkboxes.length; i++) {
                            checkboxes[i].className = "multiSelect checkboxLayer hide";
                        }
                        e.stopPropagation();
                    }
                }
            });
            if (!Array.prototype.indexOf) {
                Array.prototype.indexOf = function(what, i) {
                    i = i || 0;
                    var L = this.length;
                    while (i < L) {
                        if (this[i] === what) return i;
                        ++i;
                    }
                    return -1;
                };
            }
        }
    };
} ]);

"use strict";

angular.module("kyc.directives").directive("shapeshift", [ "UtilsService", "$timeout", function(UtilsService, $timeout) {
    return {
        restrict: "A",
        link: function(scope, element, attrs) {
            $timeout(function() {
                var $shaper = $(element).shapeshift(scope.$eval(attrs.shapeshift));
                $shaper.on("ss-rearranged", function(e, selected) {
                    UtilsService.reOrderWidgets(element);
                });
            });
        }
    };
} ]);

angular.module("kyc.charts").factory("AllCharts", [ "$q", "OrderService", "PayingCustomers", "OrdersPerCustomer", "AverageOrderValue", "ItemsOrdered", "OrdersByOutlet", "MostPopularItems", "TimeOfOrdersPlaced", "CustomersPie", "CustomersBar", "Revenue", "NumberOfOrders", "MenuItemPopularity", function($q, OrderService, PayingCustomers, OrdersPerCustomer, AverageOrderValue, ItemsOrdered, OrdersByOutlet, MostPopularItems, TimeOfOrdersPlaced, CustomersPie, CustomersBar, Revenue, NumberOfOrders, MenuItemPopularity) {
    var defer = $q.defer();
    var initialMinDate;
    var initialMaxDate;
    var currency;
    var charts = {
        payingCustomers: PayingCustomers,
        ordersPerCustomer: OrdersPerCustomer,
        averageOrderValue: AverageOrderValue,
        itemsOrdered: ItemsOrdered,
        ordersByOutlet: OrdersByOutlet,
        mostPopularItems: MostPopularItems,
        timeOfOrdersPlaced: TimeOfOrdersPlaced,
        customersPie: CustomersPie,
        customersBar: CustomersBar,
        revenue: Revenue,
        numberOfOrders: NumberOfOrders,
        menuItemPopularity: MenuItemPopularity
    };
    function init(minDate, maxDate, currencySymbol, selectedOutlets) {
        currency = currencySymbol;
        initialMinDate = minDate;
        initialMaxDate = maxDate;
        OrderService.load(function(orders) {
            prepareCharts(orders, minDate, maxDate, selectedOutlets);
        });
    }
    function findOutlet(selectedOutlets, outletId) {
        var found = false;
        angular.forEach(selectedOutlets, function(outlet) {
            if (!found && outlet.id == outletId) found = outlet;
        });
        return found;
    }
    function prepareCharts(orders, minDate, maxDate, selectedOutlets) {
        if (!minDate) minDate = initialMinDate;
        if (!maxDate) maxDate = initialMaxDate;
        if (!selectedOutlets) selectedOutlets = [];
        angular.forEach(charts, function(chart, key) {
            chart.clearData();
        });
        angular.forEach(orders, function(order) {
            if (selectedOutlets.length === 0 || findOutlet(selectedOutlets, order.outletId)) {
                var created = new Date(order.created).getTime();
                angular.forEach(charts, function(chart) {
                    chart.setData(order, minDate, maxDate);
                });
            }
        });
        angular.forEach(charts, function(chart, key) {
            if (chart.onSetDataComplete) {
                chart.onSetDataComplete(minDate, maxDate, currency);
            }
        });
        defer.resolve(charts);
    }
    function getPreparedCharts() {
        var retCharts = [];
        angular.forEach(charts, function(chart) {
            if (chart.getHighChart) {
                retCharts.push(chart.getHighChart());
            } else {
                retCharts.push(chart);
            }
        });
        return retCharts;
    }
    return {
        init: init,
        promise: defer.promise,
        getPreparedCharts: getPreparedCharts,
        prepareCharts: prepareCharts
    };
} ]);

angular.module("kyc.charts").factory("ChartHelper", [ "$filter", "TickInterval", function($filter, TickInterval) {
    function formatDate(timestamp) {
        var date = new Date(timestamp);
        return $filter("date")(date, "dd-MMM-yyyy");
    }
    function getPercentage(data, oldData) {
        var totalData = getPeriodTotal(data);
        var totalOldData = getPeriodTotal(oldData);
        var percentage = totalData * 100 / totalOldData;
        return percentage === Infinity ? "" : percentage.toFixed(2);
    }
    function getPeriodTotal(data) {
        var total = 0;
        angular.forEach(data, function(d) {
            total += d[1];
        });
        return total.toFixed(0);
    }
    var FilterCharts = {
        day: function(data, valueOf) {
            return data.filter(function(y, index) {
                return moment(y[0]).valueOf() === moment(valueOf).valueOf();
            });
        },
        week: function(data, valueOf) {
            return data.filter(function(y, index) {
                return moment(y[0]).week() === moment(valueOf).week();
            });
        },
        month: function(data, valueOf) {
            return data.filter(function(y, index) {
                return moment(y[0]).month() == moment(valueOf).month();
            });
        }
    };
    var CalculateCharts = {
        day: function(data, dataRow) {
            var daysFiltered = FilterCharts.day(data, dataRow[0]);
            var dataRowCopied = angular.copy(dataRow);
            if (daysFiltered.length) {
                daysFiltered[1] += +dataRowCopied[1];
            } else {
                dataRowCopied[0] = moment(dataRowCopied[0]).startOf("day").valueOf();
                data.push(dataRowCopied);
            }
        },
        week: function(data, dataRow) {
            var weekFiltered = FilterCharts.week(data, dataRow[0]);
            var dataRowCopied = angular.copy(dataRow);
            if (weekFiltered.length) {
                data[data.indexOf(weekFiltered[0])][1] += +dataRowCopied[1];
            } else {
                dataRowCopied[0] = moment(dataRowCopied[0]).startOf("week").valueOf();
                data.push(dataRowCopied);
            }
        },
        month: function(data, dataRow) {
            var monthsFiltered = FilterCharts.month(data, dataRow[0]);
            var dataRowCopied = angular.copy(dataRow);
            if (monthsFiltered.length) {
                data[data.indexOf(monthsFiltered[0])][1] += dataRowCopied[1];
            } else {
                dataRowCopied[0] = moment(dataRowCopied[0]).startOf("month").valueOf();
                data.push(dataRowCopied);
            }
        }
    };
    function getPreparedAreaData(chartData, minTimestamp, maxTimestamp, showDecimal) {
        showDecimal = showDecimal ? showDecimal : false;
        var previousSpecifiedTimestamp = moment(minTimestamp - (maxTimestamp - minTimestamp));
        var weekTimestamp = moment().subtract("week", 1);
        var lastWeekTimestamp = moment().subtract("week", 2);
        var monthTimestamp = moment().subtract("month", 1);
        var lastMonthTimestamp = moment().subtract("month", 2);
        var threeMonthsTimestamp = moment().subtract("month", 3);
        var lastThreeMonthsTimestamp = moment().subtract("month", 6);
        var sixMonthsTimestamp = moment().subtract("month", 6);
        var lastSixMonthsTimestamp = moment().subtract("month", 12);
        var yearTimestamp = moment().subtract("year", 1);
        var lastYearTimestamp = moment().subtract("year", 2);
        var data = [];
        var dataModal = [];
        var previousSpecifiedData = [];
        var weekData = [];
        var previousWeekData = [];
        var monthData = [];
        var previousMonthData = [];
        var threeMonthsData = [];
        var previousThreeMonthsData = [];
        var sixMonthsData = [];
        var previousSixMonthsData = [];
        var previousYearData = [];
        var total = 0;
        var yearData = [];
        var dateType = calculateTickIntervalForString({
            maxTimestamp: maxTimestamp,
            minTimestamp: minTimestamp
        });
        var functionFilteredDates = null;
        switch (dateType) {
          case "day":
            functionFilteredDates = CalculateCharts.day;
            break;

          case "week":
            functionFilteredDates = CalculateCharts.week;
            break;

          case "month":
            functionFilteredDates = CalculateCharts.month;
            break;
        }
        angular.forEach(chartData, function(dR, key) {
            var orderDate = Number(key);
            var dataRow = [ Number(key), Number(dR.toFixed(2)) ];
            if (minTimestamp <= orderDate && maxTimestamp >= orderDate) {
                functionFilteredDates(dataModal, dataRow);
                data.push(dataRow);
                total += dR;
            } else if (orderDate < minTimestamp && orderDate >= previousSpecifiedTimestamp) {
                previousSpecifiedData.push(dataRow);
            }
            if (orderDate >= weekTimestamp) {
                CalculateCharts.day(weekData, dataRow);
            }
            if (orderDate >= lastWeekTimestamp && orderDate < weekTimestamp) previousWeekData.push(dataRow);
            if (orderDate >= monthTimestamp) {
                CalculateCharts.day(monthData, dataRow);
            }
            if (orderDate >= lastMonthTimestamp && orderDate < monthTimestamp) previousMonthData.push(dataRow);
            if (orderDate >= threeMonthsTimestamp) {
                CalculateCharts.week(threeMonthsData, dataRow);
            }
            if (orderDate >= lastThreeMonthsTimestamp && orderDate < threeMonthsTimestamp) previousThreeMonthsData.push(dataRow);
            if (orderDate >= sixMonthsTimestamp) {
                CalculateCharts.week(sixMonthsData, dataRow);
            }
            if (orderDate >= lastSixMonthsTimestamp && orderDate < sixMonthsTimestamp) previousSixMonthsData.push(dataRow);
            if (orderDate >= yearTimestamp) {
                CalculateCharts.month(yearData, dataRow);
            }
            if (orderDate >= lastYearTimestamp && orderDate < yearTimestamp) previousYearData.push(dataRow);
        });
        data.sort(sortData);
        dataModal.sort(sortData);
        weekData.sort(sortData);
        previousWeekData.sort(sortData);
        monthData.sort(sortData);
        previousMonthData.sort(sortData);
        threeMonthsData.sort(sortData);
        previousThreeMonthsData.sort(sortData);
        sixMonthsData.sort(sortData);
        previousSixMonthsData.sort(sortData);
        yearData.sort(sortData);
        previousYearData.sort(sortData);
        if (showDecimal) {
            total = total.toFixed(2);
        }
        return {
            data: data,
            dataModal: dataModal,
            previousSpecifiedData: previousSpecifiedData,
            weekData: weekData,
            previousWeekData: previousWeekData,
            monthData: monthData,
            previousMonthData: previousMonthData,
            threeMonthsData: threeMonthsData,
            previousThreeMonthsData: previousThreeMonthsData,
            sixMonthsData: sixMonthsData,
            previousSixMonthsData: previousSixMonthsData,
            yearData: yearData,
            previousYearData: previousYearData,
            total: total,
            minTimestamp: minTimestamp,
            maxTimestamp: maxTimestamp
        };
    }
    function calculateTickInterval(prepData) {
        var daysDiff = moment(prepData.maxTimestamp, "X").diff(moment(prepData.minTimestamp, "X"), "days");
        switch (true) {
          case daysDiff < 32:
            return TickInterval.DAY;
            break;

          case daysDiff < 92:
            return TickInterval.WEEK;
            break;

          case daysDiff < 183:
            return TickInterval.WEEK_THREE;
            break;

          default:
            return TickInterval.MONTH;
            break;
        }
    }
    function calculateTickIntervalForString(prepData) {
        var daysDiff = moment(prepData.maxTimestamp, "X").diff(moment(prepData.minTimestamp, "X"), "days");
        switch (true) {
          case daysDiff < 32:
            return "day";
            break;

          case daysDiff < 183:
            return "week";
            break;

          default:
            return "month";
            break;
        }
    }
    function completeEmptyData(data) {
        var maxTimeStampForWhile = data.max;
        var minTimestampForWhile = data.min;
        var responseData = angular.copy(data.value);
        while (true) {
            var valueOf = maxTimeStampForWhile.valueOf();
            if (valueOf < minTimestampForWhile) {
                break;
            }
            var dataFiltered = data.filterData(responseData, valueOf);
            if (!dataFiltered.length) {
                var valueObject = [ valueOf, 0 ];
                responseData.push(valueObject);
            }
            maxTimeStampForWhile = maxTimeStampForWhile.subtract(data.dateType, 1);
        }
        responseData.sort(sortData);
        return responseData;
    }
    function getModalOptions(prepData) {
        return [ {
            name: _tr("Specified Dates"),
            value: getPeriodTotal(prepData.data),
            percent: getPercentage(prepData.data, prepData.previousSpecifiedData),
            active: true,
            data: completeEmptyData({
                max: moment(prepData.maxTimestamp).startOf("day"),
                min: moment(prepData.minTimestamp).startOf("day").valueOf(),
                value: prepData.dataModal,
                dateType: calculateTickIntervalForString(prepData),
                filterData: function(data, valueOf) {
                    switch (this.dateType) {
                      case "day":
                        return FilterCharts.day(data, valueOf);
                        break;

                      case "week":
                        return FilterCharts.week(data, valueOf);
                        break;

                      case "month":
                        return FilterCharts.month(data, valueOf);
                        break;
                    }
                }
            }),
            tickInterval: calculateTickInterval(prepData),
            minTimestamp: prepData.minTimestamp,
            maxTimestamp: prepData.maxTimestamp
        }, {
            name: _tr("Week"),
            value: getPeriodTotal(prepData.weekData),
            percent: getPercentage(prepData.weekData, prepData.previousWeekData),
            data: completeEmptyData({
                max: moment().startOf("day"),
                min: moment().subtract("week", 1).startOf("day").valueOf(),
                value: prepData.weekData,
                dateType: "day",
                filterData: FilterCharts.day
            }),
            tickInterval: TickInterval.DAY,
            minTimestamp: moment().subtract("week", 1),
            maxTimestamp: moment()
        }, {
            name: _tr("Month"),
            value: getPeriodTotal(prepData.monthData),
            percent: getPercentage(prepData.monthData, prepData.previousMonthData),
            data: completeEmptyData({
                max: moment().startOf("day"),
                min: moment().subtract("month", 1).startOf("day").valueOf(),
                value: prepData.monthData,
                dateType: "day",
                filterData: FilterCharts.day
            }),
            tickInterval: TickInterval.DAY,
            minTimestamp: moment().subtract("month", 1),
            maxTimestamp: moment()
        }, {
            name: _tr("3 Months"),
            value: getPeriodTotal(prepData.threeMonthsData),
            percent: getPercentage(prepData.threeMonthsData, prepData.previousThreeMonthsData),
            data: completeEmptyData({
                max: moment().startOf("day"),
                min: moment().subtract("month", 3).startOf("day").valueOf(),
                value: prepData.threeMonthsData,
                dateType: "week",
                filterData: FilterCharts.week
            }),
            tickInterval: TickInterval.WEEK,
            minTimestamp: moment().subtract("month", 3),
            maxTimestamp: moment()
        }, {
            name: _tr("6 Months"),
            value: getPeriodTotal(prepData.sixMonthsData),
            percent: getPercentage(prepData.sixMonthsData, prepData.previousSixMonthsData),
            data: completeEmptyData({
                max: moment().startOf("day"),
                min: moment().subtract("month", 6).startOf("day").valueOf(),
                value: prepData.sixMonthsData,
                dateType: "week",
                filterData: FilterCharts.week
            }),
            tickInterval: TickInterval.WEEK_THREE,
            minTimestamp: moment().subtract("month", 6),
            maxTimestamp: moment()
        }, {
            name: _tr("Year"),
            value: getPeriodTotal(prepData.yearData),
            percent: getPercentage(prepData.yearData, prepData.previousYearData),
            data: completeEmptyData({
                max: moment().startOf("day"),
                min: moment().subtract("year", 1).startOf("day").valueOf(),
                value: prepData.yearData,
                dateType: "month",
                filterData: FilterCharts.month
            }),
            tickInterval: TickInterval.MONTH,
            minTimestamp: moment().subtract("year", 1),
            maxTimestamp: moment()
        } ];
    }
    function sortData(a, b) {
        return a[0] - b[0];
    }
    return {
        formatDate: formatDate,
        getPercentage: getPercentage,
        getPeriodTotal: getPeriodTotal,
        getPreparedAreaData: getPreparedAreaData,
        getModalOptions: getModalOptions
    };
} ]);

angular.module("kyc.charts").factory("PayingCustomers", [ "ChartType", function(ChartType) {
    var type = ChartType.NUMBER;
    var newCustomers = [];
    var repeatedCustomers = [];
    var title = _tr("Total Customers");
    function clearData() {
        newCustomers = [];
        repeatedCustomers = [];
    }
    function setData(order, minDate, maxDate) {
        var orderData = moment(order.created);
        if (orderData >= minDate && orderData <= maxDate) {
            var customerId = order.userId;
            if (newCustomers.indexOf(customerId) === -1) {
                newCustomers.push(customerId);
            } else {
                if (repeatedCustomers.indexOf(customerId) === -1) repeatedCustomers.push(customerId);
            }
        }
    }
    function getData() {
        return newCustomers.length;
    }
    function getType() {
        return type;
    }
    function getHighChart() {
        return {
            type: type,
            title: title,
            data: getData()
        };
    }
    return {
        getData: getData,
        getType: getType,
        setData: setData,
        getHighChart: getHighChart,
        clearData: clearData
    };
} ]);

angular.module("kyc.charts").factory("OrdersPerCustomer", [ "ChartType", function(ChartType) {
    var type = ChartType.NUMBER;
    var newCustomers = [];
    var repeatedCustomers = [];
    var orders = 0;
    var title = _tr("Orders per Customer");
    function clearData() {
        newCustomers = [];
        repeatedCustomers = [];
        orders = 0;
    }
    function setData(order, minDate, maxDate) {
        var orderData = moment(order.created);
        if (orderData >= minDate && orderData <= maxDate) {
            orders++;
            var customerId = order.userId;
            if (newCustomers.indexOf(customerId) === -1) {
                newCustomers.push(customerId);
            } else {
                if (repeatedCustomers.indexOf(customerId) === -1) repeatedCustomers.push(customerId);
            }
        }
    }
    function getData() {
        return (orders / newCustomers.length).toFixed(2);
    }
    function getType() {
        return type;
    }
    function getHighChart() {
        return {
            type: type,
            title: title,
            data: getData()
        };
    }
    return {
        getData: getData,
        getType: getType,
        setData: setData,
        getHighChart: getHighChart,
        clearData: clearData
    };
} ]);

angular.module("kyc.charts").factory("AverageOrderValue", [ "ChartType", function(ChartType) {
    var type = ChartType.NUMBER;
    var ordersTotal = 0;
    var numOfOrders = 0;
    var title = _tr("Average Order Value");
    function setData(order, minDate, maxDate) {
        var orderData = moment(order.created);
        if (orderData >= minDate && orderData <= maxDate) {
            numOfOrders++;
            ordersTotal += order.total;
        }
    }
    function clearData() {
        ordersTotal = 0;
        numOfOrders = 0;
    }
    function getData() {
        return (ordersTotal / numOfOrders).toFixed(2);
    }
    function getType() {
        return type;
    }
    function getHighChart() {
        return {
            type: type,
            title: title,
            data: getData(),
            currency: "£"
        };
    }
    return {
        getData: getData,
        getType: getType,
        setData: setData,
        getHighChart: getHighChart,
        clearData: clearData
    };
} ]);

angular.module("kyc.charts").factory("ItemsOrdered", [ "ChartType", function(ChartType) {
    var type = ChartType.NUMBER;
    var itemsOrdered = 0;
    var title = _tr("Items Ordered");
    function setData(order, minDate, maxDate) {
        var orderData = moment(order.created);
        if (orderData >= minDate && orderData <= maxDate) {
            angular.forEach(order.items, function(item) {
                itemsOrdered += item.qty;
            });
        }
    }
    function getData() {
        return itemsOrdered;
    }
    function getType() {
        return type;
    }
    function getHighChart() {
        return {
            type: type,
            title: title,
            data: getData()
        };
    }
    function clearData() {
        itemsOrdered = 0;
    }
    return {
        getData: getData,
        getType: getType,
        setData: setData,
        getHighChart: getHighChart,
        clearData: clearData
    };
} ]);

angular.module("kyc.charts").factory("OrdersByOutlet", [ "ChartType", "Colors", "OutletService", "ChartHelper", function(ChartType, Colors, OutletService, ChartHelper) {
    var type = ChartType.PIE;
    var ordersByOutlet = {};
    var colorIndex = 0;
    var title = _tr("Orders By Outlet");
    var minTimestamp = 0;
    var maxTimestamp = 0;
    function clearData() {
        colorIndex = 0;
        ordersByOutlet = {};
    }
    function setData(order, minDate, maxDate) {
        minTimestamp = minDate.valueOf();
        maxTimestamp = maxDate.valueOf();
        var orderData = moment(order.created);
        if (orderData >= minDate && orderData <= maxDate) {
            var outletId = order.outletId;
            if (ordersByOutlet[outletId] === undefined) ordersByOutlet[outletId] = {
                y: 0
            };
            ordersByOutlet[outletId].y += 1;
        }
    }
    function getData() {
        colorIndex = 0;
        var ordersByOutletArray = [];
        angular.forEach(ordersByOutlet, function(item, outletId) {
            ordersByOutletArray.push({
                name: OutletService.getOutletName(outletId),
                color: Colors[colorIndex],
                y: item.y
            });
            colorIndex++;
        });
        return ordersByOutletArray;
    }
    function getType() {
        return type;
    }
    function getHighChart() {
        return {
            type: type,
            title: title,
            data: getData(),
            getPdf: getPdf,
            getCsv: getCsv
        };
    }
    function getCsv() {
        var data = getData();
        var csvData = [ [ moment(minTimestamp).format("DD-MMM-YYYY") + " - " + moment(maxTimestamp).format("DD-MMM-YYYY") ], [ title ] ];
        angular.forEach(data, function(d) {
            csvData.push([ d.name, d.y ]);
        });
        return {
            data: csvData
        };
    }
    function getPdf() {
        return chartInfo = {
            type: type,
            title: title,
            startDate: minTimestamp,
            endDate: maxTimestamp,
            dataJson: JSON.stringify(getData()),
            categories: getCategories()
        };
    }
    function getCategories() {
        var arr = [];
        angular.forEach(ordersByOutlet, function(item, outletId) {
            arr.push(OutletService.getOutletName(outletId));
        });
        return arr;
    }
    return {
        getData: getData,
        getType: getType,
        setData: setData,
        getHighChart: getHighChart,
        clearData: clearData
    };
} ]);

angular.module("kyc.charts").factory("MostPopularItems", [ "ChartType", "Colors", "ChartHelper", function(ChartType, Colors, ChartHelper) {
    var type = ChartType.PIE;
    var items = {};
    var title = _tr("Most Popular Items");
    var minTimestamp = 0;
    var maxTimestamp = 0;
    var top5 = [ {
        y: 0,
        color: Colors[0]
    }, {
        y: 0,
        color: Colors[1]
    }, {
        y: 0,
        color: Colors[2]
    }, {
        y: 0,
        color: Colors[3]
    }, {
        y: 0,
        color: Colors[4]
    } ];
    function clearData() {
        items = {};
        top5 = [ {
            y: 0,
            color: Colors[0]
        }, {
            y: 0,
            color: Colors[1]
        }, {
            y: 0,
            color: Colors[2]
        }, {
            y: 0,
            color: Colors[3]
        }, {
            y: 0,
            color: Colors[4]
        } ];
    }
    function setData(order, minDate, maxDate) {
        minTimestamp = minDate.valueOf();
        maxTimestamp = maxDate.valueOf();
        var orderData = moment(order.created);
        if (orderData >= minDate && orderData <= maxDate) {
            angular.forEach(order.items, function(item) {
                if (items[item.menuItemId] !== undefined) items[item.menuItemId].quantity++; else items[item.menuItemId] = {
                    name: item.name,
                    quantity: 1
                };
            });
        }
    }
    function onSetDataComplete() {
        for (var id in items) {
            for (var pos in top5) {
                if (items[id].quantity > top5[pos].y) {
                    for (var i = top5.length - 1; i > pos; i--) {
                        top5[i].y = top5[i - 1].y;
                        top5[i].name = top5[i - 1].name;
                    }
                    top5[pos].y = items[id].quantity;
                    top5[pos].name = items[id].name;
                    break;
                }
            }
        }
        top5 = _.filter(top5, function(row) {
            return row.name !== undefined;
        });
    }
    function getData() {
        return top5;
    }
    function getType() {
        return type;
    }
    function getHighChart() {
        return {
            type: type,
            title: title,
            data: getData(),
            getPdf: getPdf,
            getCsv: getCsv
        };
    }
    function getCsv() {
        var data = getData();
        var csvData = [ [ moment(minTimestamp).format("DD-MMM-YYYY") + " - " + moment(maxTimestamp).format("DD-MMM-YYYY") ], [ title ] ];
        angular.forEach(data, function(d) {
            csvData.push([ d.name, d.y ]);
        });
        return {
            data: csvData
        };
    }
    function getPdf() {
        return chartInfo = {
            type: type,
            title: title,
            startDate: minTimestamp,
            endDate: maxTimestamp,
            dataJson: angular.toJson(getData()),
            categories: getCategories()
        };
    }
    function getCategories() {
        var arr = [];
        angular.forEach(top5, function(item) {
            arr.push(item.name);
        });
        return arr;
    }
    return {
        getData: getData,
        getType: getType,
        setData: setData,
        onSetDataComplete: onSetDataComplete,
        getHighChart: getHighChart,
        clearData: clearData
    };
} ]);

angular.module("kyc.charts").factory("TimeOfOrdersPlaced", [ "ChartType", "Colors", "ChartHelper", function(ChartType, Colors, ChartHelper) {
    var type = ChartType.PIE;
    var colorIndex = 0;
    var title = _tr("Time of Orders Placed");
    var data;
    var minTimestamp = 0;
    var maxTimestamp = 0;
    function clearData() {
        data = [ {
            name: _tr("On the day"),
            y: 0,
            color: Colors[0]
        }, {
            name: _tr("In advance"),
            y: 0,
            color: Colors[1]
        } ];
        colorIndex = 0;
    }
    function setData(order, minDate, maxDate) {
        minTimestamp = minDate.valueOf();
        maxTimestamp = maxDate.valueOf();
        var orderData = moment(order.created);
        if (orderData >= minDate && orderData <= maxDate) {
            if (order.created !== undefined && order.pickupTime !== undefined) {
                var placed = new Date(order.created).setHours(0, 0, 0, 0);
                var pickup = new Date(order.pickupTime).setHours(0, 0, 0, 0);
                if (placed === pickup) {
                    data[0].y++;
                } else {
                    data[1].y++;
                }
            }
        }
    }
    function onSetDataComplete() {}
    function getData() {
        return data;
    }
    function getType() {
        return type;
    }
    function getHighChart() {
        return {
            type: type,
            title: title,
            data: getData(),
            getPdf: getPdf,
            getCsv: getCsv
        };
    }
    function getCsv() {
        var data = getData();
        var csvData = [ [ moment(minTimestamp).format("DD-MMM-YYYY") + " - " + moment(maxTimestamp).format("DD-MMM-YYYY") ], [ title ] ];
        angular.forEach(data, function(d) {
            csvData.push([ d.name, d.y ]);
        });
        return {
            data: csvData
        };
    }
    function getPdf() {
        return chartInfo = {
            type: type,
            title: title,
            startDate: minTimestamp,
            endDate: maxTimestamp,
            dataJson: JSON.stringify(data),
            categories: [ _tr("On the day"), _tr("In advance") ]
        };
    }
    return {
        getData: getData,
        getType: getType,
        setData: setData,
        onSetDataComplete: onSetDataComplete,
        getHighChart: getHighChart,
        clearData: clearData
    };
} ]);

angular.module("kyc.charts").factory("CustomersPie", [ "ChartType", "Colors", "ChartHelper", function(ChartType, Colors, ChartHelper) {
    var type = ChartType.PIE;
    var colorIndex = 0;
    var title = _tr("Customers (Pie)");
    var data = [ {
        name: _tr("New"),
        y: 0,
        color: Colors[0]
    }, {
        name: _tr("Returning"),
        y: 0,
        color: Colors[1]
    } ];
    var newCustomers = [];
    var repeatedCustomers = [];
    var minTimestamp = 0;
    var maxTimestamp = 0;
    function clearData() {
        colorIndex = 0;
        data = [ {
            name: _tr("New"),
            y: 0,
            color: Colors[0]
        }, {
            name: _tr("Returning"),
            y: 0,
            color: Colors[1]
        } ];
        newCustomers = [];
        repeatedCustomers = [];
    }
    function setData(order, minDate, maxDate) {
        minTimestamp = minDate.valueOf();
        maxTimestamp = maxDate.valueOf();
        var orderData = moment(order.created);
        if (orderData >= minDate && orderData <= maxDate) {
            var customerId = order.userId;
            if (newCustomers.indexOf(customerId) === -1) {
                newCustomers.push(customerId);
                data[0].y++;
            } else {
                if (repeatedCustomers.indexOf(customerId) === -1) {
                    repeatedCustomers.push(customerId);
                    data[1].y++;
                }
            }
        }
    }
    function getData() {
        return data;
    }
    function getType() {
        return type;
    }
    function getHighChart() {
        return {
            type: type,
            title: title,
            data: getData(),
            getPdf: getPdf,
            getCsv: getCsv
        };
    }
    function getCsv() {
        var data = getData();
        var csvData = [ [ moment(minTimestamp).format("DD-MMM-YYYY") + " - " + moment(maxTimestamp).format("DD-MMM-YYYY") ], [ title ] ];
        angular.forEach(data, function(d) {
            csvData.push([ d.name, d.y ]);
        });
        return {
            data: csvData
        };
    }
    function getPdf() {
        return chartInfo = {
            type: type,
            title: title,
            startDate: minTimestamp,
            endDate: maxTimestamp,
            dataJson: JSON.stringify(data),
            categories: [ data[0].name, data[1].name ]
        };
    }
    return {
        getData: getData,
        getType: getType,
        setData: setData,
        getHighChart: getHighChart,
        clearData: clearData
    };
} ]);

angular.module("kyc.charts").factory("CustomersBar", [ "ChartType", "ChartHelper", function(ChartType, ChartHelper) {
    var type = ChartType.COLUMN;
    var title = _tr("Customers (Bar)");
    var data = [ {
        name: _tr("New"),
        y: 0
    }, {
        name: _tr("Returning"),
        y: 0
    } ];
    var newCustomers = [];
    var repeatedCustomers = [];
    var minTimestamp = 0;
    var maxTimestamp = 0;
    function setData(order, minDate, maxDate) {
        minTimestamp = minDate.valueOf();
        maxTimestamp = maxDate.valueOf();
        var orderData = moment(order.created);
        if (orderData >= minDate && orderData <= maxDate) {
            var customerId = order.userId;
            if (newCustomers.indexOf(customerId) === -1) {
                newCustomers.push(customerId);
                data[0].y++;
            } else {
                if (repeatedCustomers.indexOf(customerId) === -1) {
                    repeatedCustomers.push(customerId);
                    data[1].y++;
                }
            }
        }
    }
    function clearData() {
        data = [ {
            name: _tr("New"),
            y: 0
        }, {
            name: _tr("Returning"),
            y: 0
        } ];
        newCustomers = [];
        repeatedCustomers = [];
    }
    function getData() {
        return data;
    }
    function getType() {
        return type;
    }
    function getHighChart() {
        return {
            type: type,
            title: title,
            data: getData(),
            getPdf: getPdf,
            getCsv: getCsv
        };
    }
    function getCsv() {
        var data = getData();
        var csvData = [ [ moment(minTimestamp).format("DD-MMM-YYYY") + " - " + moment(maxTimestamp).format("DD-MMM-YYYY") ], [ title ] ];
        angular.forEach(data, function(d) {
            csvData.push([ d.name, d.y ]);
        });
        return {
            data: csvData
        };
    }
    function getPdf() {
        return chartInfo = {
            type: type,
            title: title,
            startDate: minTimestamp,
            endDate: maxTimestamp,
            dataJson: JSON.stringify([ data[0].y, data[1].y ]),
            categories: [ data[0].name, data[1].name ]
        };
    }
    return {
        getData: getData,
        getType: getType,
        setData: setData,
        getHighChart: getHighChart,
        clearData: clearData
    };
} ]);

angular.module("kyc.charts").factory("NumberOfOrders", [ "ChartType", "ChartHelper", function(ChartType, ChartHelper) {
    var type = ChartType.AREA;
    var dailyOrders = {};
    var title = _tr("Number of Orders");
    var minTimestamp = 0;
    var maxTimestamp = 0;
    var prepData = {};
    function setData(order, minDate, maxDate) {
        var timestamp = moment(order.paid).startOf("day").valueOf();
        if (dailyOrders[timestamp]) dailyOrders[timestamp]++; else dailyOrders[timestamp] = 1;
    }
    function onSetDataComplete(minDate, maxDate) {
        minTimestamp = minDate.valueOf();
        maxTimestamp = maxDate.valueOf();
        prepData = ChartHelper.getPreparedAreaData(dailyOrders, minDate, maxDate);
    }
    function getData() {
        return prepData.data;
    }
    function getType() {
        return type;
    }
    function getHighChart() {
        return {
            type: type,
            title: title,
            data: getData(),
            numberLeft: prepData.total,
            numberRight: ChartHelper.getPercentage(getData(), prepData.previousSpecifiedData),
            modal: getModal(),
            getPdf: getPdf,
            getCsv: getCsv,
            tooltipText: _tr(" orders")
        };
    }
    function getPdf() {
        return chartInfo = {
            type: type,
            title: title,
            startDate: minTimestamp,
            endDate: maxTimestamp,
            total: prepData.total,
            currency: "",
            percentage: ChartHelper.getPercentage(prepData.data, prepData.previousSpecifiedData),
            dataJson: JSON.stringify(getData())
        };
    }
    function clearData() {
        prepData = {};
        dailyOrders = {};
    }
    function getCsv() {
        var data = getData();
        var csvData = [ [ moment(minTimestamp).format("DD-MMM-YYYY") + " - " + moment(maxTimestamp).format("DD-MMM-YYYY") ], [ title ] ];
        angular.forEach(data, function(d) {
            csvData.push([ ChartHelper.formatDate(d[0]), d[1] ]);
        });
        return {
            data: csvData
        };
    }
    function getModal() {
        return {
            highcharts: {
                type: ChartType.AREA_MODAL
            },
            options: ChartHelper.getModalOptions(prepData)
        };
    }
    return {
        getData: getData,
        getType: getType,
        clearData: clearData,
        setData: setData,
        onSetDataComplete: onSetDataComplete,
        getHighChart: getHighChart
    };
} ]);

angular.module("kyc.charts").factory("MenuItemPopularity", [ "ChartType", "ChartHelper", function(ChartType, ChartHelper) {
    var type = ChartType.AREA;
    var title = _tr("Menu Item Popularity");
    var menuItems = {};
    var selectedItem = -1;
    var minDate;
    var maxDate;
    var prepData = {};
    var items = [];
    function setData(order, minDate, maxDate) {
        var timestamp = moment(order.created).startOf("day").valueOf();
        angular.forEach(order.items, function(item) {
            if (menuItems[item.menuItemId] === undefined) {
                selectedItem = selectedItem == -1 ? item.menuItemId : selectedItem;
                items.push({
                    name: item.name,
                    menuItemId: item.menuItemId,
                    callback: selectItem
                });
                menuItems[item.menuItemId] = {};
            }
            if (menuItems[item.menuItemId][timestamp] === undefined) {
                menuItems[item.menuItemId][timestamp] = 0;
            }
            menuItems[item.menuItemId][timestamp]++;
        });
    }
    function selectItem(itemId, cb) {
        clearData();
        selectedItem = itemId;
        onSetDataComplete(minDate, maxDate);
        cb(getHighChart());
    }
    function onSetDataComplete(minDateP, maxDateP) {
        minDate = minDateP;
        maxDate = maxDateP;
        prepData = ChartHelper.getPreparedAreaData(menuItems[selectedItem], minDate, maxDate, false);
    }
    function getData() {
        return prepData.data;
    }
    function getType() {
        return type;
    }
    function getHighChart() {
        return {
            type: type,
            title: title,
            data: getData(),
            numberLeft: prepData.total,
            modal: getModal(),
            items: items,
            getPdf: getPdf,
            getCsv: getCsv,
            tooltipText: _tr(" orders")
        };
    }
    function getCsv() {
        var data = getData();
        var csvData = [ [ minDate.format("DD-MMM-YYYY") + " - " + maxDate.format("DD-MMM-YYYY") ], [ getItemName(selectedItem) ] ];
        angular.forEach(data, function(d) {
            csvData.push([ ChartHelper.formatDate(d[0]), d[1] ]);
        });
        return {
            data: csvData
        };
    }
    function getPdf() {
        return chartInfo = {
            type: type,
            title: title + " - " + getItemName(selectedItem),
            startDate: minDate.valueOf(),
            endDate: maxDate.valueOf(),
            total: prepData.total,
            percentage: ChartHelper.getPercentage(prepData.data, prepData.previousSpecifiedData),
            dataJson: JSON.stringify(getData())
        };
    }
    function clearData() {
        prepData = {};
    }
    function getItemName(itemId) {
        var found = false;
        angular.forEach(items, function(item) {
            if (item.menuItemId == itemId) found = item.name;
        });
        return found;
    }
    function getModal() {
        return {
            highcharts: {
                type: ChartType.AREA_MODAL
            },
            options: ChartHelper.getModalOptions(prepData)
        };
    }
    return {
        getData: getData,
        getType: getType,
        clearData: clearData,
        setData: setData,
        onSetDataComplete: onSetDataComplete,
        getHighChart: getHighChart
    };
} ]);

angular.module("kyc.charts").factory("Revenue", [ "ChartType", "ChartHelper", function(ChartType, ChartHelper) {
    var type = ChartType.AREA;
    var dailyRevenue = {};
    var title = _tr("Revenue");
    var prepData = {};
    var minTimestamp = 0;
    var maxTimestamp = 0;
    var currency;
    function setData(order, minDate, maxDate) {
        var timestamp = moment(order.paid).startOf("day").valueOf();
        if (dailyRevenue[timestamp]) dailyRevenue[timestamp] += order.total; else dailyRevenue[timestamp] = order.total;
    }
    function onSetDataComplete(minDate, maxDate, currencySymbol) {
        currency = currencySymbol;
        minTimestamp = minDate.valueOf();
        maxTimestamp = maxDate.valueOf();
        prepData = ChartHelper.getPreparedAreaData(dailyRevenue, minDate, maxDate, true);
    }
    function getData() {
        return prepData.data;
    }
    function getType() {
        return type;
    }
    function getHighChart() {
        return {
            type: type,
            title: title,
            data: getData(),
            currency: currency,
            numberLeft: prepData.total,
            numberRight: ChartHelper.getPercentage(prepData.data, prepData.previousSpecifiedData),
            modal: getModal(),
            getPdf: getPdf,
            getCsv: getCsv,
            tooltipText: decodeURI(currency)
        };
    }
    function getCsv() {
        var data = getData();
        var csvData = [ [ moment(minTimestamp).format("DD-MMM-YYYY") + " - " + moment(maxTimestamp).format("DD-MMM-YYYY") ], [ title ] ];
        angular.forEach(data, function(d) {
            csvData.push([ ChartHelper.formatDate(d[0]), d[1] ]);
        });
        return {
            data: csvData
        };
    }
    function clearData() {
        dailyRevenue = {};
        prepData = {};
    }
    function getPdf() {
        return chartInfo = {
            type: type,
            title: title,
            startDate: minTimestamp,
            endDate: maxTimestamp,
            total: prepData.total,
            currency: currency,
            percentage: ChartHelper.getPercentage(prepData.data, prepData.previousSpecifiedData),
            dataJson: JSON.stringify(getData())
        };
    }
    function getModal() {
        return {
            highcharts: {
                type: ChartType.AREA_MODAL
            },
            options: ChartHelper.getModalOptions(prepData)
        };
    }
    return {
        getData: getData,
        getType: getType,
        clearData: clearData,
        setData: setData,
        onSetDataComplete: onSetDataComplete,
        getHighChart: getHighChart
    };
} ]);

angular.module("kyc.reports").factory("AllReports", [ "$q", "Report", "NewCustomers", "ZeroOrdersCustomers", "OneTimeBuyers", "MostFrequentBuyers", "HighestSpendingCustomers", "CustomersIncreasingOrders", "CustomersIncreasingSpend", "CustomersDecreasingOrders", "CustomersDecreasingSpend", "SleepingCustomers", "MostPopularItemsReport", "ItemPopularityIncrease", "ItemPopularityDecrease", "HighestGrossingDays", "LowestGrossingDays", "HighestOrderDays", "LowestOrderDays", "HighestOrderHours", "HighestGrossingHours", "VENUE_ID", function($q, Report, NewCustomers, ZeroOrdersCustomers, OneTimeBuyers, MostFrequentBuyers, HighestSpendingCustomers, CustomersIncreasingOrders, CustomersIncreasingSpend, CustomersDecreasingOrders, CustomersDecreasingSpend, SleepingCustomers, MostPopularItems, ItemPopularityIncrease, ItemPopularityDecrease, HighestGrossingDays, LowestGrossingDays, HighestOrderDays, LowestOrderDays, HighestOrderHours, HighestGrossingHours, VENUE_ID) {
    var AllReports = function() {};
    var reportsList = [ NewCustomers, ZeroOrdersCustomers, OneTimeBuyers, MostFrequentBuyers, HighestSpendingCustomers, CustomersIncreasingOrders, CustomersIncreasingSpend, CustomersDecreasingOrders, CustomersDecreasingSpend, SleepingCustomers, MostPopularItems, ItemPopularityIncrease, ItemPopularityDecrease, HighestGrossingDays, LowestGrossingDays, HighestOrderDays, LowestOrderDays, HighestOrderHours, HighestGrossingHours ];
    var optionsMap = {
        dateJoined: _tr("Date Joined"),
        name: _tr("Name"),
        email: _tr("Email Address"),
        marketing: _tr("Marketing"),
        dateOfOrder: _tr("Date of Order"),
        numberOfOrders: _tr("Number of Orders"),
        totalSpent: _tr("Total Spent"),
        percentIncrease: _tr("% Increase"),
        percentDecrease: _tr("% Decrease"),
        lastOrder: _tr("Last Order"),
        itemName: _tr("Item Name"),
        quantitySold: _tr("Quantity Sold"),
        day: _tr("Day"),
        date: _tr("Date"),
        valueSold: _tr("Value Sold")
    };
    function setTitles(report) {
        var titles = [];
        var data = report.getData();
        for (var key in data) {
            angular.forEach(data[key], function(val, prop) {
                if (String(prop[0]) != "$") titles.push(prop);
            });
            report.setTitles(titles);
            break;
        }
    }
    AllReports.init = function(allOrders) {
        var deferred = $q.defer();
        fetchData().then(initReports).then(function() {
            angular.forEach(reportsList, function(report) {
                report.setData(AllReports.data);
            });
            angular.forEach(reportsList, function(report) {
                if (report.onSetDataComplete) {
                    report.onSetDataComplete();
                }
                setTitles(report);
                report.title = report.getTitle();
            });
            deferred.resolve();
        });
        return deferred.promise;
    };
    function fetchData() {
        var now = moment().valueOf();
        var lastMonthEnd = moment().subtract("month", 1).valueOf();
        var lastMonthBegin = moment().subtract("month", 2).valueOf();
        return $q.all([ Report.items({
            venueId: VENUE_ID
        }).$promise, Report.orders({
            venueId: VENUE_ID
        }).$promise, Report.customerOrders({
            venueId: VENUE_ID
        }).$promise, Report.customerOrders({
            venueId: VENUE_ID,
            maxDate: now,
            minDate: lastMonthEnd
        }).$promise, Report.customerOrders({
            venueId: VENUE_ID,
            maxDate: lastMonthEnd,
            minDate: lastMonthBegin
        }).$promise ]);
    }
    function initReports(data) {
        console.log("data", data);
        AllReports.data = {
            items: data[0],
            orders: prepareOrders(data[1]),
            customerOrders: prepareCustomerOrders(data[2], data[3], data[4])
        };
        var promises = [];
        angular.forEach(reportsList, function(report) {
            if (report.init) promises.push(report.init());
        });
        return $q.all(promises);
    }
    function prepareOrders(orders) {
        angular.forEach(orders, function(order) {
            order.day = moment(order.created).startOf("day").valueOf();
            order.hour = moment(order.created).hour();
        });
        return orders;
    }
    function prepareCustomerOrders(customerOrders, thisMonthCustomerOrders, lastMonthCustomerOrders) {
        console.log(customerOrders.length, thisMonthCustomerOrders.length, lastMonthCustomerOrders.length);
        angular.forEach(customerOrders, function(customerOrder) {
            var thisMonth;
            var lastMonth;
            for (var index in thisMonthCustomerOrders) {
                if (thisMonthCustomerOrders[index].id === customerOrder.id) {
                    thisMonth = thisMonthCustomerOrders[index];
                    break;
                }
            }
            for (var index in lastMonthCustomerOrders) {
                if (lastMonthCustomerOrders[index].id === customerOrder.id) {
                    lastMonth = lastMonthCustomerOrders[index];
                    break;
                }
            }
            if (thisMonth && thisMonth.orders && lastMonth && lastMonth.orders) {
                customerOrder.orderPercentage = 100 * thisMonth.orders / lastMonth.orders;
                customerOrder.orderPercentage = thisMonth.orders > lastMonth.orders ? customerOrder.orderPercentage : -customerOrder.orderPercentage;
                customerOrder.totalPercentage = 100 * thisMonth.total / lastMonth.total;
                customerOrder.totalPercentage = thisMonth.total > lastMonth.total ? customerOrder.totalPercentage : -customerOrder.totalPercentage;
            }
        });
        return customerOrders;
    }
    AllReports.getTitle = function(prop) {
        return optionsMap[prop] ? optionsMap[prop] : prop;
    };
    AllReports.getReportsList = function() {
        return reportsList;
    };
    return AllReports;
} ]);

angular.module("kyc.reports").factory("NewCustomers", [ function() {
    var title = _tr("New Customers");
    var Report = {};
    var data = {};
    var titles = [];
    var dateRange = moment().subtract("week", 2);
    Report.setData = function(reportsData) {
        angular.forEach(reportsData.customerOrders, function(customerOrder) {
            var created = moment(customerOrder.created);
            if (created > dateRange) {
                if (data[customerOrder.id] === undefined) {
                    data[customerOrder.id] = {
                        dateJoined: customerOrder.created,
                        name: customerOrder.firstName + " " + customerOrder.lastName,
                        email: customerOrder.username,
                        marketing: customerOrder.optinLoyalty || customerOrder.optinOffers || customerOrder.optinOther
                    };
                }
            }
        });
    };
    Report.getData = function() {
        return data;
    };
    Report.setTitles = function(newTitles) {
        titles = newTitles;
    };
    Report.getTitles = function() {
        return titles;
    };
    Report.getTitle = function() {
        return title;
    };
    return Report;
} ]);

angular.module("kyc.reports").factory("ZeroOrdersCustomers", [ "VenueCustomers", "VENUE_ID", function(VenueCustomers, VENUE_ID) {
    var title = _tr("Customers with zero orders");
    var titles = [];
    var data = {};
    var Report = {};
    var customers;
    var customersWithOrders = [];
    Report.init = function($q) {
        data = {};
        customersWithOrders = [];
        customers = VenueCustomers.query({
            id: VENUE_ID
        });
        return customers.$promise;
    };
    Report.setData = function(reportsData) {
        angular.forEach(reportsData.customerOrders, function(customerOrder) {
            if (customerOrder.total) data[customerOrder.id] = {
                dateJoined: customerOrder.created,
                name: customerOrder.firstName + " " + customerOrder.lastName,
                email: customerOrder.username,
                marketing: customerOrder.optinLoyalty || customerOrder.optinOffers || customerOrder.optinOther
            };
        });
    };
    Report.onSetDataComplete = function() {};
    Report.getData = function() {
        return data;
    };
    Report.setTitles = function(newTitles) {
        titles = newTitles;
    };
    Report.getTitles = function() {
        return titles;
    };
    Report.getTitle = function() {
        return title;
    };
    return Report;
} ]);

angular.module("kyc.reports").factory("OneTimeBuyers", [ function() {
    var title = _tr("One Time Buyers");
    var Report = {};
    var data = {};
    var titles = [];
    Report.setData = function(reportsData) {
        angular.forEach(reportsData.customerOrders, function(customerOrder) {
            if (data[customerOrder.id] === undefined && customerOrder.orders === 1) {
                data[customerOrder.id] = {
                    dateJoined: customerOrder.created,
                    dateOfOrder: customerOrder.firstOrder,
                    name: customerOrder.firstName + " " + customerOrder.lastName,
                    email: customerOrder.username,
                    marketing: customerOrder.optinLoyalty || customerOrder.optinOffers || customerOrder.optinOther
                };
            }
        });
        console.log("set data", data);
    };
    Report.getData = function() {
        return data;
    };
    Report.setTitles = function(newTitles) {
        titles = newTitles;
    };
    Report.getTitles = function() {
        return titles;
    };
    Report.getTitle = function() {
        return title;
    };
    return Report;
} ]);

angular.module("kyc.reports").factory("MostFrequentBuyers", [ function() {
    var title = _tr("Most Frequent Buyers");
    var Report = {};
    var data = {};
    var titles = [];
    Report.setData = function(reportsData) {
        reportsData.customerOrders.sort(function(a, b) {
            return a.orders - b.orders;
        });
        angular.forEach(reportsData.customerOrders, function(customerOrder) {
            var created = moment(customerOrder.created);
            if (data[customerOrder.id] === undefined) {
                data[customerOrder.id] = {
                    numberOfOrders: customerOrder.orders,
                    name: customerOrder.firstName + " " + customerOrder.lastName,
                    email: customerOrder.username,
                    marketing: customerOrder.optinLoyalty || customerOrder.optinOffers || customerOrder.optinOther
                };
            }
        });
    };
    Report.orderBy = "numberOfOrders";
    Report.getData = function() {
        return data;
    };
    Report.setTitles = function(newTitles) {
        titles = newTitles;
    };
    Report.getTitles = function() {
        return titles;
    };
    Report.getTitle = function() {
        return title;
    };
    return Report;
} ]);

angular.module("kyc.reports").factory("HighestSpendingCustomers", [ function() {
    var title = _tr("Highest Spending Customers");
    var Report = {};
    var data = {};
    var titles = [];
    Report.setData = function(reportsData) {
        angular.forEach(reportsData.customerOrders, function(customerOrder) {
            var created = moment(customerOrder.created);
            if (data[customerOrder.id] === undefined) {
                data[customerOrder.id] = {
                    totalSpent: customerOrder.total === null ? 0 : customerOrder.total,
                    name: customerOrder.firstName + " " + customerOrder.lastName,
                    email: customerOrder.username,
                    marketing: customerOrder.optinLoyalty || customerOrder.optinOffers || customerOrder.optinOther
                };
            }
        });
    };
    Report.orderBy = "totalSpent";
    Report.getData = function() {
        return data;
    };
    Report.setTitles = function(newTitles) {
        titles = newTitles;
    };
    Report.getTitles = function() {
        return titles;
    };
    Report.getTitle = function() {
        return title;
    };
    return Report;
} ]);

angular.module("kyc.reports").factory("CustomersIncreasingOrders", [ function() {
    var title = _tr("Customers Increasing Orders");
    var Report = {};
    var data = {};
    var titles = [];
    Report.setData = function(reportsData) {
        console.log(reportsData);
        angular.forEach(reportsData.customerOrders, function(customerOrder) {
            if (data[customerOrder.id] === undefined && !isNaN(customerOrder.orderPercentage) && customerOrder.orderPercentage > 0) {
                data[customerOrder.id] = {
                    percentIncrease: customerOrder.orderPercentage.toFixed(0),
                    name: customerOrder.firstName + " " + customerOrder.lastName,
                    email: customerOrder.username,
                    marketing: customerOrder.optinLoyalty || customerOrder.optinOffers || customerOrder.optinOther
                };
            }
        });
        console.log("set data", data);
    };
    Report.orderby = "percentIncrease";
    Report.getData = function() {
        return data;
    };
    Report.setTitles = function(newTitles) {
        titles = newTitles;
    };
    Report.getTitles = function() {
        return titles;
    };
    Report.getTitle = function() {
        return title;
    };
    return Report;
} ]);

angular.module("kyc.reports").factory("CustomersDecreasingOrders", [ function() {
    var title = _tr("Customers Decreasing Orders");
    var Report = {};
    var data = {};
    var titles = [];
    Report.setData = function(reportsData) {
        console.log(reportsData);
        angular.forEach(reportsData.customerOrders, function(customerOrder) {
            if (data[customerOrder.id] === undefined && !isNaN(customerOrder.orderPercentage) && customerOrder.orderPercentage < 0) {
                data[customerOrder.id] = {
                    percentDecrease: customerOrder.orderPercentage.toFixed(0),
                    name: customerOrder.firstName + " " + customerOrder.lastName,
                    email: customerOrder.username,
                    marketing: customerOrder.optinLoyalty || customerOrder.optinOffers || customerOrder.optinOther
                };
            }
        });
        console.log("set data", data);
    };
    Report.orderby = "percentIncrease";
    Report.getData = function() {
        return data;
    };
    Report.setTitles = function(newTitles) {
        titles = newTitles;
    };
    Report.getTitles = function() {
        return titles;
    };
    Report.getTitle = function() {
        return title;
    };
    return Report;
} ]);

angular.module("kyc.reports").factory("CustomersIncreasingSpend", [ function() {
    var title = _tr("Customers Increasing Spend");
    var Report = {};
    var data = {};
    var titles = [];
    Report.setData = function(reportsData) {
        console.log(reportsData);
        angular.forEach(reportsData.customerOrders, function(customerOrder) {
            if (data[customerOrder.id] === undefined && !isNaN(customerOrder.totalPercentage) && customerOrder.totalPercentage > 0) {
                data[customerOrder.id] = {
                    percentIncrease: customerOrder.totalPercentage.toFixed(0),
                    name: customerOrder.firstName + " " + customerOrder.lastName,
                    email: customerOrder.username,
                    marketing: customerOrder.optinLoyalty || customerOrder.optinOffers || customerOrder.optinOther
                };
            }
        });
        console.log("set data", data);
    };
    Report.orderby = "percentIncrease";
    Report.getData = function() {
        return data;
    };
    Report.setTitles = function(newTitles) {
        titles = newTitles;
    };
    Report.getTitles = function() {
        return titles;
    };
    Report.getTitle = function() {
        return title;
    };
    return Report;
} ]);

angular.module("kyc.reports").factory("CustomersDecreasingSpend", [ function() {
    var title = _tr("Customers Increasing Spend");
    var Report = {};
    var data = {};
    var titles = [];
    Report.setData = function(reportsData) {
        console.log(reportsData);
        angular.forEach(reportsData.customerOrders, function(customerOrder) {
            if (data[customerOrder.id] === undefined && !isNaN(customerOrder.totalPercentage) && customerOrder.totalPercentage < 0) {
                data[customerOrder.id] = {
                    percentDecrease: customerOrder.totalPercentage.toFixed(0),
                    name: customerOrder.firstName + " " + customerOrder.lastName,
                    email: customerOrder.username,
                    marketing: customerOrder.optinLoyalty || customerOrder.optinOffers || customerOrder.optinOther
                };
            }
        });
        console.log("set data", data);
    };
    Report.orderby = "percentIncrease";
    Report.getData = function() {
        return data;
    };
    Report.setTitles = function(newTitles) {
        titles = newTitles;
    };
    Report.getTitles = function() {
        return titles;
    };
    Report.getTitle = function() {
        return title;
    };
    return Report;
} ]);

angular.module("kyc.reports").factory("SleepingCustomers", [ function() {
    var title = _tr("Sleeping Customers");
    var Report = {};
    var data = {};
    var titles = [];
    var dateRange = moment().subtract("month", 3);
    Report.setData = function(reportsData) {
        angular.forEach(reportsData.customerOrders, function(customerOrder) {
            if (data[customerOrder.id] === undefined && moment(customerOrder.lastOrder).valueOf() > dateRange.valueOf()) {
                data[customerOrder.id] = {
                    lastOrder: customerOrder.lastOrder,
                    name: customerOrder.firstName + " " + customerOrder.lastName,
                    email: customerOrder.username,
                    marketing: customerOrder.optinLoyalty || customerOrder.optinOffers || customerOrder.optinOther
                };
            }
        });
        console.log("set data", data);
    };
    Report.orderby = "lastOrder";
    Report.getData = function() {
        return data;
    };
    Report.setTitles = function(newTitles) {
        titles = newTitles;
    };
    Report.getTitles = function() {
        return titles;
    };
    Report.getTitle = function() {
        return title;
    };
    return Report;
} ]);

angular.module("kyc.reports").factory("MostPopularItemsReport", [ function() {
    var title = _tr("Most Popular Items");
    var Report = {};
    var data = {};
    var titles = [];
    Report.setData = function(reportsData) {
        angular.forEach(reportsData.items, function(item) {
            if (data[item.menuItemId] === undefined) {
                data[item.menuItemId] = {
                    itemName: item.name,
                    quantitySold: item.qty
                };
            } else {
                data[item.menuItemId].quantitySold += item.qty;
            }
        });
    };
    Report.orderBy = "quantitySold";
    Report.getData = function() {
        return data;
    };
    Report.setTitles = function(newTitles) {
        titles = newTitles;
    };
    Report.getTitles = function() {
        return titles;
    };
    Report.getTitle = function() {
        return title;
    };
    return Report;
} ]);

angular.module("kyc.reports").factory("ItemPopularityIncrease", [ function() {
    var title = _tr("Item Popularity Increase");
    var Report = {};
    var data = {};
    var tempData = {};
    var titles = [];
    Report.setData = function(reportsData) {
        var thisMonth = moment().subtract("month", 1).format("X");
        var lastMonth = moment().subtract("month", 2).format("X");
        angular.forEach(reportsData.items, function(item) {
            if (tempData[item.menuItemId] === undefined) {
                tempData[item.menuItemId] = {
                    name: item.name,
                    $thisMonthQuantitySold: 0,
                    $lastMonthQuantitySold: 0
                };
            }
            var created = moment(item.created).format("X");
            if (created >= thisMonth) {
                tempData[item.menuItemId].$thisMonthQuantitySold += item.qty;
            } else if (created > lastMonth) {
                tempData[item.menuItemId].$lastMonthQuantitySold += item.qty;
            }
        });
        console.log(tempData, "tempData");
    };
    Report.onSetDataComplete = function() {
        angular.forEach(tempData, function(item, key) {
            console.log("each item", item);
            if (item.$thisMonthQuantitySold > item.$lastMonthQuantitySold) {
                var popularity = 100 * item.$thisMonthQuantitySold / item.$lastMonthQuantitySold;
                data[key] = {
                    itemName: item.name,
                    quantitySold: item.$thisMonthQuantitySold,
                    percentIncrease: popularity.toFixed(0)
                };
            }
        });
        console.log("data", data);
    };
    Report.orderBy = "";
    Report.getData = function() {
        return data;
    };
    Report.setTitles = function(newTitles) {
        titles = newTitles;
    };
    Report.getTitles = function() {
        return titles;
    };
    Report.getTitle = function() {
        return title;
    };
    return Report;
} ]);

angular.module("kyc.reports").factory("ItemPopularityDecrease", [ function() {
    var title = _tr("Item Popularity Decrease");
    var Report = {};
    var data = {};
    var tempData = {};
    var titles = [];
    Report.setData = function(reportsData) {
        var thisMonth = moment().subtract("month", 1).format("X");
        var lastMonth = moment().subtract("month", 2).format("X");
        angular.forEach(reportsData.items, function(item) {
            if (tempData[item.menuItemId] === undefined) {
                tempData[item.menuItemId] = {
                    name: item.name,
                    $thisMonthQuantitySold: 0,
                    $lastMonthQuantitySold: 0
                };
            }
            var created = moment(item.created).format("X");
            if (created >= thisMonth) {
                tempData[item.menuItemId].$thisMonthQuantitySold += item.qty;
            } else if (created > lastMonth) {
                tempData[item.menuItemId].$lastMonthQuantitySold += item.qty;
            }
        });
        console.log(tempData, "tempData");
    };
    Report.onSetDataComplete = function() {
        angular.forEach(tempData, function(item, key) {
            if (item.$thisMonthQuantitySold < item.$lastMonthQuantitySold) {
                var popularity = 100 * item.$thisMonthQuantitySold / item.$lastMonthQuantitySold;
                data[key] = {
                    itemName: item.name,
                    quantitySold: item.$thisMonthQuantitySold,
                    percentDecrease: popularity.toFixed(0)
                };
            }
        });
        console.log("data", data);
    };
    Report.orderBy = "";
    Report.getData = function() {
        return data;
    };
    Report.setTitles = function(newTitles) {
        titles = newTitles;
    };
    Report.getTitles = function() {
        return titles;
    };
    Report.getTitle = function() {
        return title;
    };
    return Report;
} ]);

angular.module("kyc.reports").factory("HighestGrossingDays", [ function() {
    var title = _tr("Highest Grossing Days");
    var Report = {};
    var data = [];
    var titles = [];
    var dateRange = moment().subtract("month", 1);
    var itemsToShow = 10;
    Report.setData = function(reportsData) {
        var tempData = {};
        var grouped = _.groupBy(reportsData.orders, "day");
        angular.forEach(grouped, function(day, key) {
            if (key > dateRange.valueOf()) {
                angular.forEach(day, function(order) {
                    if (tempData[key] === undefined) {
                        tempData[key] = {
                            day: order.created,
                            date: order.created,
                            valueSold: order.total
                        };
                    } else {
                        tempData[key].valueSold += order.total;
                    }
                });
            }
        });
        data = _.sortBy(tempData, function(row) {
            return -row.valueSold;
        }).slice(0, itemsToShow);
    };
    Report.orderBy = "valueSold";
    Report.getData = function() {
        return data;
    };
    Report.setTitles = function(newTitles) {
        titles = newTitles;
    };
    Report.getTitles = function() {
        return titles;
    };
    Report.getTitle = function() {
        return title;
    };
    return Report;
} ]);

angular.module("kyc.reports").factory("LowestGrossingDays", [ function() {
    var title = _tr("Lowest Grossing Days");
    var Report = {};
    var data = [];
    var titles = [];
    var dateRange = moment().subtract("month", 1);
    var itemsToShow = 10;
    Report.setData = function(reportsData) {
        var tempData = {};
        var grouped = _.groupBy(reportsData.orders, "day");
        angular.forEach(grouped, function(day, key) {
            if (key > dateRange.valueOf()) {
                angular.forEach(day, function(order) {
                    if (tempData[key] === undefined) {
                        tempData[key] = {
                            day: order.created,
                            date: order.created,
                            valueSold: order.total
                        };
                    } else {
                        tempData[key].valueSold += order.total;
                    }
                });
            }
        });
        data = _.sortBy(tempData, function(row) {
            return row.valueSold;
        }).slice(0, itemsToShow);
    };
    Report.orderBy = "valueSold";
    Report.direction = false;
    Report.getData = function() {
        return data;
    };
    Report.setTitles = function(newTitles) {
        titles = newTitles;
    };
    Report.getTitles = function() {
        return titles;
    };
    Report.getTitle = function() {
        return title;
    };
    return Report;
} ]);

angular.module("kyc.reports").factory("HighestOrderDays", [ function() {
    var title = _tr("Highest Order Days");
    var Report = {};
    var data = [];
    var titles = [];
    var dateRange = moment().subtract("month", 1);
    var itemsToShow = 10;
    Report.setData = function(reportsData) {
        var tempData = {};
        var grouped = _.groupBy(reportsData.orders, "day");
        angular.forEach(grouped, function(day, key) {
            if (key > dateRange.valueOf()) {
                angular.forEach(day, function(order) {
                    if (tempData[key] === undefined) {
                        tempData[key] = {
                            day: order.created,
                            date: order.created,
                            numberOfOrders: 1
                        };
                    } else {
                        tempData[key].numberOfOrders++;
                    }
                });
            }
        });
        data = _.sortBy(tempData, function(row) {
            return -row.numberOfOrders;
        }).slice(0, itemsToShow);
    };
    Report.orderBy = "numberOfOrders";
    Report.getData = function() {
        return data;
    };
    Report.setTitles = function(newTitles) {
        titles = newTitles;
    };
    Report.getTitles = function() {
        return titles;
    };
    Report.getTitle = function() {
        return title;
    };
    return Report;
} ]);

angular.module("kyc.reports").factory("LowestOrderDays", [ function() {
    var title = _tr("Lowest Order Days");
    var Report = {};
    var data = [];
    var titles = [];
    var dateRange = moment().subtract("month", 1);
    var itemsToShow = 10;
    Report.setData = function(reportsData) {
        var tempData = {};
        var grouped = _.groupBy(reportsData.orders, "day");
        angular.forEach(grouped, function(day, key) {
            if (key > dateRange.valueOf()) {
                angular.forEach(day, function(order) {
                    if (tempData[key] === undefined) {
                        tempData[key] = {
                            day: order.created,
                            date: order.created,
                            numberOfOrders: 1
                        };
                    } else {
                        tempData[key].numberOfOrders++;
                    }
                });
            }
        });
        data = _.sortBy(tempData, function(row) {
            return row.numberOfOrders;
        }).slice(0, itemsToShow);
    };
    Report.orderBy = "numberOfOrders";
    Report.direction = false;
    Report.getData = function() {
        return data;
    };
    Report.setTitles = function(newTitles) {
        titles = newTitles;
    };
    Report.getTitles = function() {
        return titles;
    };
    Report.getTitle = function() {
        return title;
    };
    return Report;
} ]);

angular.module("kyc.reports").factory("HighestGrossingHours", [ function() {
    var title = _tr("Highest Grossing Hours");
    var Report = {};
    var data = [];
    var titles = [];
    var itemsToShow = 10;
    Report.setData = function(reportsData) {
        var tempData = {};
        var grouped = _.groupBy(reportsData.orders, "hour");
        console.log("grouped", grouped);
        angular.forEach(grouped, function(day, key) {
            angular.forEach(day, function(order) {
                if (tempData[key] === undefined) {
                    tempData[key] = {
                        timeSlot: moment(order.created).format("HH:00"),
                        valueSold: order.total
                    };
                } else {
                    tempData[key].valueSold += order.total;
                }
            });
        });
        console.log("tempData", tempData);
        data = _.sortBy(tempData, function(row) {
            return row.valueSold;
        }).slice(0, itemsToShow);
    };
    Report.orderBy = "valueSold";
    Report.getData = function() {
        return data;
    };
    Report.setTitles = function(newTitles) {
        titles = newTitles;
    };
    Report.getTitles = function() {
        return titles;
    };
    Report.getTitle = function() {
        return title;
    };
    return Report;
} ]);

angular.module("kyc.reports").factory("HighestOrderHours", [ function() {
    var title = _tr("Highest Order Hours");
    var Report = {};
    var data = [];
    var titles = [];
    var itemsToShow = 10;
    Report.setData = function(reportsData) {
        var tempData = {};
        var grouped = _.groupBy(reportsData.orders, "hour");
        console.log("grouped", grouped);
        angular.forEach(grouped, function(day, key) {
            angular.forEach(day, function(order) {
                if (tempData[key] === undefined) {
                    tempData[key] = {
                        timeSlot: moment(order.created).format("HH:00"),
                        numberOfOrders: 1
                    };
                } else {
                    tempData[key].numberOfOrders++;
                }
            });
        });
        console.log("tempData", tempData);
        data = _.sortBy(tempData, function(row) {
            return -row.numberOfOrders;
        }).slice(0, itemsToShow);
    };
    Report.orderBy = "timeSlot";
    Report.direction = false;
    Report.getData = function() {
        return data;
    };
    Report.setTitles = function(newTitles) {
        titles = newTitles;
    };
    Report.getTitles = function() {
        return titles;
    };
    Report.getTitle = function() {
        return title;
    };
    return Report;
} ]);

"use strict";

angular.module("kyc.filters", []).filter("interpolate", [ "version", function(version) {
    return function(text) {
        return String(text).replace(/\%VERSION\%/gm, version);
    };
} ]).filter("orderObjectBy", function() {
    return function(items, field, reverse) {
        var filtered = [];
        angular.forEach(items, function(item) {
            filtered.push(item);
        });
        filtered.sort(function(a, b) {
            return a[field] > b[field] ? 1 : -1;
        });
        if (reverse) filtered.reverse();
        return filtered;
    };
}).filter("marketing", function() {
    return function(marketing) {
        return marketing === 1 ? _tr("Active") : " - ";
    };
}).filter("timeAgo", function() {
    return function(date) {
        if (typeof date !== "object") {
            date = moment(date);
        }
        var seconds = Math.floor((moment() - date).valueOf() / 1e3);
        var intervalType;
        var interval = Math.floor(seconds / 31536e3);
        if (interval >= 1) {
            if (interval > 1) intervalType = _tr("years ago"); else intervalType = _tr("year ago");
        } else {
            interval = Math.floor(seconds / 2592e3);
            if (interval >= 1) {
                if (interval > 1) intervalType = _tr("months ago"); else intervalType = _tr("month ago");
            } else {
                interval = Math.floor(seconds / 86400);
                if (interval >= 1) {
                    if (interval > 1) intervalType = _tr("days ago"); else {
                        interval = "";
                        intervalType = _tr("yesterday");
                    }
                } else {
                    interval = Math.floor(seconds / 3600);
                    if (interval >= 1) {
                        if (interval > 1) intervalType = _tr("hours ago"); else intervalType = _tr("hour ago");
                    } else {
                        interval = Math.floor(seconds / 60);
                        if (interval >= 1) {
                            if (interval > 1) intervalType = _tr("minutes ago"); else intervalType = _tr("minute ago");
                        } else {
                            interval = seconds;
                            if (interval > 1) intervalType = _tr("seconds ago"); else intervalType = _tr("second ago");
                        }
                    }
                }
            }
        }
        return interval + " " + intervalType;
    };
});
//# sourceMappingURL=all.min.map